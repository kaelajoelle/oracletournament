<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Welcome To The Oracle Trials</title>

  <!-- Optional runtime configuration -->
  <script src="./site/app-config.js" data-origin="app-config"></script>

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=IM+Fell+English+SC&family=Open+Sans:wght@400;600&display=swap" rel="stylesheet">

  <style>
  :root{
    --bg:#f8f2df; --panel:#f5eed5; --ink:#3b2b1a; --muted:#6e5a3e;
    --accent:#b38b46; --border:#c8b27a;
  }

  body{
    margin:0;
    font-family:'Roboto Serif',serif;
    color:var(--ink);
    line-height:1.6;
    background-color:var(--bg);
    background-image:
      radial-gradient(circle at 18% 22%, rgba(255,245,212,0.72), rgba(255,245,212,0)),
      radial-gradient(circle at 82% 16%, rgba(242,226,188,0.62), rgba(242,226,188,0)),
      linear-gradient(135deg, rgba(179,139,70,0.18), rgba(179,139,70,0.05)),
      repeating-linear-gradient(115deg,
        rgba(112,86,48,0.08) 0px,
        rgba(112,86,48,0.08) 2px,
        rgba(248,242,223,0.08) 2px,
        rgba(248,242,223,0.08) 6px
      );
    background-size:420px 420px, 520px 520px, cover, 14px 14px;
    background-repeat:no-repeat, no-repeat, no-repeat, repeat;
    background-attachment:fixed;
    padding-bottom: env(safe-area-inset-bottom);
  }

  /* Main Font Sizes */
  body, p, label, input, select, textarea, button {
    font-family: 'Roboto Serif';
    font-size: clamp(1rem, 2.3vw, 1.2rem);
    line-height: 1.5;
  }
    




  header{
    text-align:center;
    padding:1.2rem 1rem 1rem;
    border-bottom:2px solid var(--border);
    background:rgba(248,242,223,.9);
    font-family:'IM Fell English SC',serif;
  }

  h1{
    font-size:clamp(1.5rem, 7vw, 2.2rem);
    margin:.2rem 0 .3rem;
    color:var(--ink);
  }
  .subtitle{
    color:var(--muted);
    font-size:clamp(1.2rem, 4vw, 1.3rem);
    font-style:italic;
  }

  .disclaimer{
    max-width:900px; margin:1rem auto; background:var(--panel);
    border:2px solid var(--border); border-radius:12px; padding:1rem 1.5rem;
    box-shadow:0 4px 15px rgba(0,0,0,.1); color:var(--muted); font-style:italic; position:relative;
  }
  .disclaimer::before{ content:"✶"; position:absolute; top:-10px; left:12px; color:var(--accent); }

  .wizard{
    display:flex;
    flex-direction:column;
    gap:1.25rem;
    max-width:1200px;
    margin:0 auto;
    padding:1.5rem;
  }

  .steps-shell{
    background:var(--panel);
    border:2px solid var(--border);
    border-radius:12px;
    padding:1rem;
    box-shadow:0 2px 6px rgba(0,0,0,.08);
    display:flex;
    flex-direction:column;
    gap:.75rem;
  }

  .steps-header{
    display:flex;
    align-items:center;
    gap:.75rem;
    flex-wrap:wrap;
  }

  .steps-header h3{
    margin:0;
    font-size:1.15rem;
    display:flex;
    align-items:center;
    gap:.5rem;
  }

  .steps-header #cfgBadge{
    font-size:.95rem;
  }

  .steps-rail{
    display:flex;
    gap:12px;
    overflow-x:auto;
    padding:4px 2px 6px;
    scroll-snap-type:x mandatory;
    scrollbar-width:thin;
  }
  .steps-rail:focus-visible{
    outline:2px solid var(--accent);
    outline-offset:4px;
  }
  .steps-rail::-webkit-scrollbar{ height:8px; }
  .steps-rail::-webkit-scrollbar-thumb{
    background-color:rgba(179,139,70,.6);
    border-radius:999px;
  }
  .steps-rail::-webkit-scrollbar-track{
    background:rgba(179,139,70,.18);
    border-radius:999px;
  }

  .step-pill{
    display:flex;
    align-items:center;
    gap:0.75rem;
    padding:0.6rem 0.9rem;
    border-radius:16px;
    border:1px solid var(--border);
    background:#efe7c8;
    min-height:52px;
    min-width:150px;
    cursor:pointer;
    box-shadow:0 1px 0 rgba(0,0,0,.06) inset;
    transition:background .2s, box-shadow .2s, transform .2s;
    scroll-snap-align:start;
    text-align:left;
    color:inherit;
  }
  .step-pill[aria-selected="true"]{
    background:linear-gradient(180deg,#fff8df,#f4e8bf);
    box-shadow:0 2px 8px rgba(179,139,70,0.25);
    border-color:#a67a33;
  }
  .step-pill:focus-visible{
    outline:3px solid #3b2b1a;
    outline-offset:2px;
  }
  .step-pill:hover{
    background:linear-gradient(180deg,#fdf3d0,#f2e4bb);
    transform:translateY(-1px);
  }

  .step-pill .step-number{
    width:32px;
    height:32px;
    border-radius:999px;
    background:#d9c38b;
    color:#4b381f;
    font-weight:700;
    display:inline-flex;
    align-items:center;
    justify-content:center;
    flex-shrink:0;
  }

  .step-pill .step-label{
    display:flex;
    flex-direction:column;
    gap:2px;
    font-weight:600;
    line-height:1.2;
  }

  .step-pill .step-label small{
    font-size:.82rem;
    color:var(--muted);
    font-weight:500;
  }

  .steps-actions{
    border:2px solid var(--border);
    border-radius:12px;
    background:var(--panel);
    box-shadow:0 1px 4px rgba(0,0,0,.08);
    padding:1rem;
    display:flex;
    flex-direction:column;
    gap:.75rem;
  }
  .steps-actions .flex{
    justify-content:flex-start;
  }

  @media (min-width: 900px){
    .steps-rail{
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
      overflow-x:visible;
      overflow-y:visible;
      padding:6px 0 0;
      gap:14px;
      scroll-snap-type:none;
    }
    .step-pill{
      min-width:0;
    }
  }

  /* minimal UI styles so it looks sane */
  .grid{ display:grid; gap:12px; }
  .grid.cols-2{ grid-template-columns:repeat(2,minmax(0,1fr)); }
  .panel,.card{
    background:var(--panel); border:2px solid var(--border); border-radius:12px; padding:12px;
  }
  .kicker{ font-size:.9rem; color:var(--muted); }
  .muted{ color:var(--muted); }
  .flex{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  .pill{ display:inline-flex; gap:8px; align-items:center; border:1px solid var(--border); padding:6px 10px; border-radius:999px; background:#efe7c8; }
  .controls{ display:flex; justify-content:space-between; margin-top:12px; }
  button{ padding:10px 14px; border-radius:10px; border:1px solid var(--border); background:#efe7c8; cursor:pointer; }
  button:focus,
  button:focus-visible,
  button:active{
    outline:2px solid var(--accent);
    outline-offset:2px;
    box-shadow:0 0 4px rgba(179,139,70,.45) inset;
  }
  button:active{ transform:translateY(1px); }
  .primary{ background:#d9c38b; }
  .secondary{ background:#e5dccc; }
  .danger{ background:#e7b0a9; }

  
  .table{ width:100%; border-collapse:collapse; }
  .table th,.table td{ border-bottom:1px solid var(--border); padding:8px 6px; text-align:left; }
    /* =============== MOBILE PATCH =============== */
@media (max-width: 700px){
  /* Background: avoid jank on mobile */
  body{
    background-attachment: scroll;
    background-size:360px 360px, 440px 440px, cover, 16px 16px;
  }

  /* Stack layout */
  .wizard{
    padding: .75rem;
    gap: 1rem;
  }
  .steps-shell{
    padding:.85rem;
  }
  .steps-rail{
    padding-bottom:8px;
  }
  .step-pill{
    min-width:140px;
  }
  .steps-actions{
    padding:.85rem;
  }

  /* Buttons: bigger tap targets */
  button{
    padding: 12px 14px;
    min-height: 44px;
  }
  .controls{ flex-direction: column; gap: 8px; }
  .controls .left, .controls .right{ width: 100%; gap: 8px; }
  .controls .right button{ width: 100%; }

  /* Cards & panels */
  .panel, .card{
    padding: 12px;
    border-radius: 10px;
  }

  /* Forms */
  input, select, textarea{ font-size: 1rem; } /* iOS zoom fix */
  .grid.cols-2{ grid-template-columns: 1fr; }
  .two{ grid-template-columns: 1fr; }

  /* Pills wrap nicely */
  .pill{ padding: 6px 10px; }

  /* Tables: make scrollable with a shadow hint */
  .table{ width: max(640px, 100%); } /* keep columns readable */
  .table-wrap{
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
    position: relative;
  }
  .table-wrap::after{
    content:"";
    position:absolute; top:0; right:0; width:24px; height:100%;
    pointer-events:none;
    background: linear-gradient(to left, rgba(0,0,0,.06), transparent);
  }

  /* Keep actions comfy on narrower phones */
  .steps-actions .flex button{ width:100%; }

  details.news-item > summary{
    flex-wrap:wrap;
    align-items:flex-start;
  }
  details.news-item > summary .dot{
    order:1;
    margin-top:.2rem;
  }
  details.news-item > summary .news-title-text{
    order:2;
    min-width:0;
  }
  details.news-item > summary .chev{
    order:3;
    margin-left:auto;
  }
  .news-body{ padding:.85rem 1rem 1rem; }
  .news-board, .quest-board, .comment-board{ padding:1rem; }

  /* Typography trims */
  .kicker{ font-size: .8rem; }
  .muted{ font-size: .8rem; }
}

@media (max-width: 600px){
  .wizard{ margin-top:.5rem; }
}

@media (max-width: 900px){
  header{ padding: clamp(.85rem, 4vw, 1rem); }
  .wizard{ padding: clamp(.5rem, 4vw, .75rem); }
  .steps-shell{ padding:.75rem; }
  .steps-actions{ padding:.75rem; }
  .steps-actions .flex{ gap:6px; }
  .steps-actions .flex button{ flex:1 1 140px; }
  .panel, .card{ padding: 10px; }
  .table-scroll{ margin:0 -4px; }
  .letter-table .table{ min-width: 420px; }
  .news-board, .quest-board, .comment-board{ padding:.85rem; margin-top:1.1rem; }
  details.news-item > summary{ gap:.5rem; }
  .comment-actions{ justify-content:stretch; }
  .comment-actions button{ flex:1 1 140px; }
  .table.avail th:first-child, .table.avail td:first-child, .avail-name{ min-width: 140px; }
  .roster-form-grid{ grid-template-columns: minmax(0,1fr); }
  .form-actions{ flex-direction: column-reverse; align-items: stretch; }
  .form-actions .primary{ width: 100%; }
  .form-actions .link-button{ align-self: center; }
}

/* Wrap any wide table in this to get the scroll behavior */
.table-wrap{ overflow: visible; } /* desktop default */
    
    /* =============== FORM & TABLE SPACING TUNE-UP =============== */

/* Labels and input alignment */
label {
  display: block;
  font-weight: 600;
  margin-bottom: 4px;
  color: var(--ink);
}

/* Inputs and selects */
input, select, textarea {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: #fcf8e8;
  box-sizing: border-box;
}

/* Ability score cards spacing */
#ability_box .card {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 12px;
  margin-bottom: 6px;
}

/* Keep the dropdown smaller so the label has room */
#ability_box select,
#ability_box input[type="number"] {
  width: 70px;
  text-align: center;
}

/* Grid spacing fixes for the Core Setup panel */
.grid.cols-2 > div {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

/* Panel padding and internal spacing */
.panel {
  padding: 1.2rem;
  border-radius: 12px;
  border: 2px solid var(--border);
  background: var(--panel);
  margin-bottom: 12px;
}

/* Better button alignment */
.controls {
  margin-top: 16px;
}
.controls .right {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
}

/* Table cleanup */
.table th, .table td {
  padding: 8px 10px;
  border-bottom: 1px solid var(--border);
}
.table th {
  background: rgba(179,139,70,0.1);
  font-weight: 600;
  text-align: center;
}
.table td {
  text-align: center;
}

/* === Step rail spacing & readability === */
.steps-shell{ padding:14px; }
.steps-shell .callout { margin-top: 14px; }
.steps-shell .callout .flex { gap: 8px; flex-wrap: wrap; }
.steps-actions .flex { margin-top: 6px; gap: 8px; flex-wrap: wrap; }


button[disabled]{ opacity:.55; cursor:not-allowed; filter:grayscale(.2); }

/* Availability table wrapper */
.table-scroll {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

/* Keep the card’s border/rounding intact */
.card { overflow: hidden; }

/* Make the availability table behave */
.table.avail {
  min-width: 760px;              /* so columns don’t crush */
  border-collapse: separate;     /* avoid weird collapsed borders while scrolling */
  border-spacing: 0;
}

.table.avail th, .table.avail td {
  border-bottom: 1px solid var(--border);
  padding: 6px 8px;
  white-space: nowrap;
}

.avail-name {
  min-width: 200px;
}

.avail-name strong {
  display: block;
}

.name-meta {
  margin-top: 4px;
  color: var(--muted);
  font-size: .85rem;
}

.name-actions {
  margin-top: 6px;
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.status-pill,
.note-pill {
  display: inline-flex;
  align-items: center;
  padding: 2px 10px;
  border-radius: 999px;
  font-size: .78rem;
  font-weight: 600;
  margin-right: 6px;
}

.status-pill {
  background: #f0f3f8;
  color: var(--ink);
}

.status-pill.status-yes {
  background: #e6f8ed;
  color: #1d7a46;
}

.status-pill.status-no {
  background: #fbeee3;
  color: #b24a3a;
}

.status-pill.status-maybe {
  background: #fffbe2;
  color: #b07f10;
}

.status-pill.status-preferred {
  background: #e8f1fa;
  color: #2a6cb0;
}

.status-pill.status-default {
  background: #ede9ff;
  color: #5a4ab0;
}

.note-pill {
  background: #f7f1da;
  color: var(--muted);
  font-weight: 500;
}

.link-button {
  background: none;
  border: none;
  padding: 0;
  font-size: .85rem;
  color: var(--accent);
  cursor: pointer;
  text-decoration: underline;
}

.link-button.danger {
  color: #b24a3a;
}

/* Optional: tighter first column */
.table.avail th:first-child, .table.avail td:first-child {
  width: 160px;
}

.table.avail input[type="checkbox"] {
  width: 22px;
  height: 22px;
  cursor: pointer;
  accent-color: var(--accent);
}

.table.avail tbody tr:hover td {
  background: rgba(255, 250, 223, .8);
}

.roster-editor {
  margin-top: 18px;
}

.roster-form {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.roster-form-grid {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 12px;
}

.roster-form-grid .form-field {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.roster-form-grid .form-field-notes {
  grid-column: 1 / -1;
}

#roster_notes {
  min-height: 64px;
  resize: vertical;
}

.form-hint {
  margin: 0;
  font-size: .85rem;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  align-items: center;
}

.form-message {
  font-size: .85rem;
  font-weight: 600;
}

.form-message.success {
  color: #1d7a46;
}

.form-message.error {
  color: #b24a3a;
}

    /* ---- Utility grids used in panels ---- */
.two {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 12px;
}

/* Callout styling used across panels */
.callout {
  background: #fff8df;
  border: 2px solid var(--border);
  border-radius: 10px;
  padding: 10px 12px;
}

/* Availability card tidy */
.avail-card {
  padding: 0;          /* let the table edge align to the card */
  border-radius: 12px;
  overflow: hidden;    /* keep rounded corners while scrolling */
}

/* Match your intent (you used .table-scroll in HTML) */
.table-scroll {
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  position: relative;
  background: var(--panel);
  padding: 8px;        /* small breathing room around the table */
}

/* Subtle fade at the right edge on mobile */
.table-scroll::after{
  content:"";
  position:absolute; top:0; right:0; width:24px; height:100%;
  pointer-events:none;
  background: linear-gradient(to left, rgba(0,0,0,.06), transparent);
}

.letter-table{
  padding: 0 6px;
}
.letter-table .table{
  min-width: 520px;
}

/* Availability table specifics */
.table.avail {
  min-width: 760px;
  border-collapse: separate;
  border-spacing: 0;
}

.table.avail thead th {
  position: sticky;
  top: 0;
  z-index: 2;
  background: rgba(179,139,70,0.12);
  backdrop-filter: blur(2px);
}

/* Keep the name column visible while you scroll horizontally */
.table.avail th:first-child,
.table.avail td:first-child {
  position: sticky;
  left: 0;
  z-index: 1;
  background: var(--panel);
  text-align: left;
  font-weight: 600;
  width: 160px;
}

/* Row separators and cell spacing */
.table.avail th, .table.avail td {
  border-bottom: 1px solid var(--border);
  padding: 6px 8px;
  white-space: nowrap;
}

    /* --- Arcane accordion --- */
details.scroll-letter {
  border: 2px solid var(--border);
  border-radius: 12px;
  background: rgba(245,238,213,0.95);
  box-shadow: 0 2px 8px rgba(0,0,0,.06);
  overflow: hidden;
}

details.scroll-letter > summary {
  list-style: none; /* hide default marker */
  cursor: pointer;
  padding: 0.9rem 1.1rem;
  font-family: 'IM Fell English SC', serif;
  font-size: 1.15rem;
  display: flex; align-items: center; gap: .6rem;
  background: linear-gradient(180deg, #fff8df, #f4e8bf);
  border-bottom: 1px solid var(--border);
  user-select: none;
}
details.scroll-letter > summary::-webkit-details-marker { display: none; }

details.scroll-letter > summary .chev {
  margin-left: auto;
  transition: transform .2s ease;
}
details.scroll-letter[open] > summary .chev { transform: rotate(90deg); }

.seal {
  display:inline-flex; align-items:center; justify-content:center;
  width: 26px; height: 26px; border-radius: 50%;
  background: #b38b46; color: #f7f2dd; font-weight: 900;
  box-shadow: inset 0 -2px 0 rgba(0,0,0,.15);
  font-family: 'IM Fell English SC', serif;
}

.scroll-content {
  padding: 1.1rem 1.25rem 1.25rem;
  font-family: 'IM Fell English SC', serif;
  line-height: 1.6;
}

/* table inside the letter */
.scroll-content .table th { text-align:center; }
.scroll-content .table { margin: .8rem 0; }

.news-board{
  margin-top:1.5rem;
  padding:1.25rem 1.35rem;
  border:2px solid var(--border);
  border-radius:12px;
  background:rgba(245,238,213,0.9);
  box-shadow:0 2px 6px rgba(0,0,0,.08);
}
.news-board h3{
  margin:0 0 .35rem;
  font-family:'IM Fell English SC',serif;
  font-size:1.4rem;
}
.news-board p{
  margin:.4rem 0 0;
}
details.news-item{
  margin-top:.9rem;
  border:1px solid var(--border);
  border-radius:10px;
  background:rgba(255,248,223,0.7);
  overflow:hidden;
}
details.news-item > summary{
  list-style:none;
  cursor:pointer;
  display:flex;
  align-items:center;
  gap:.65rem;
  padding:.85rem 1rem;
  font-weight:600;
  user-select:none;
}
details.news-item > summary::-webkit-details-marker{ display:none; }
details.news-item > summary .news-title-text{
  flex:1;
}
details.news-item > summary .dot{
  width:.75rem;
  height:.75rem;
  border-radius:50%;
  background:var(--accent);
  box-shadow:0 0 0 2px rgba(59,43,26,0.08);
}
details.news-item > summary .chev{
  margin-left:auto;
  transition:transform .2s ease;
}
details.news-item[open] > summary{
  background:linear-gradient(180deg,#fff8df,#f4e8bf);
  border-bottom:1px solid var(--border);
}
details.news-item[open] > summary .chev{ transform:rotate(90deg); }
.news-body{
  padding:.95rem 1.1rem 1.1rem;
  line-height:1.55;
}
.news-body p{
  margin:0 0 .75rem;
}
.news-body ul{
  margin:.2rem 0 .75rem 1.2rem;
}
.news-body li{ margin-bottom:.4rem; }

.quest-board{
  margin-top:1.5rem;
  padding:1.2rem 1.35rem;
  border:2px solid var(--border);
  border-radius:12px;
  background:rgba(245,238,213,0.95);
  box-shadow:0 2px 6px rgba(0,0,0,.08);
}
.quest-board h3{
  margin:0;
  font-family:'IM Fell English SC',serif;
  font-size:1.5rem;
}
.quest-board p{
  margin:.4rem 0;
}
.quest-list{
  margin-top:.85rem;
  display:grid;
  gap:.75rem;
}
.quest-card{
  border:1px solid var(--border);
  border-radius:10px;
  padding:.9rem 1rem;
  background:#fffdf2;
  box-shadow:0 1px 3px rgba(0,0,0,.06);
}
.quest-card h4{
  margin:0 0 .3rem;
  font-size:1.1rem;
}
.quest-meta{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
  font-size:.9rem;
  color:var(--muted);
}
.quest-notes{
  margin-top:.35rem;
}

.comment-board{
  margin-top:1.5rem;
  padding:1.25rem 1.35rem;
  border:2px solid var(--border);
  border-radius:12px;
  background:rgba(245,238,213,0.9);
  box-shadow:0 2px 6px rgba(0,0,0,.08);
}
.comment-board h3{
  margin:0;
  font-family:'IM Fell English SC',serif;
  font-size:1.4rem;
}
.comment-board p{
  margin:.5rem 0 1rem;
}
.comment-form{
  display:flex;
  flex-direction:column;
  gap:.75rem;
}
.comment-form-grid{
  display:flex;
  flex-wrap:wrap;
  gap:.75rem;
}
.comment-form-grid .form-field{
  flex:1 1 180px;
  display:flex;
  flex-direction:column;
  gap:.35rem;
}
.comment-form-grid input{
  padding:8px 10px;
  border-radius:8px;
  border:1px solid var(--border);
  font-family:'Roboto Serif',serif;
  background:#fff8df;
}
.comment-form textarea{
  resize:vertical;
  min-height:90px;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid var(--border);
  font-family:'Roboto Serif',serif;
  background:#fff8df;
}
.comment-actions{
  display:flex;
  gap:8px;
  justify-content:flex-end;
  flex-wrap:wrap;
}
.comment-actions button{ width:auto; }
.comment-status{
  margin-top:.25rem;
  font-size:.9rem;
  font-weight:600;
}
.comment-status[data-tone="success"]{ color:#1d7a46; }
.comment-status[data-tone="info"]{ color:var(--muted); }
.comment-status[data-tone="error"]{ color:#a13b3b; }
.comment-list{
  margin-top:1rem;
  display:flex;
  flex-direction:column;
  gap:.75rem;
}
.comment-item{
  background:#fff8df;
  border:1px solid var(--border);
  border-radius:10px;
  padding:.85rem 1rem;
  position:relative;
  box-shadow:0 1px 3px rgba(0,0,0,0.04);
}
.comment-item[data-pending="true"]{
  opacity:0.6;
}
.comment-item[data-pending="true"] button{
  cursor:wait;
}
.comment-item p{ margin:0; }
.comment-meta{
  display:flex;
  flex-wrap:wrap;
  gap:.5rem;
  font-size:.82rem;
  color:var(--muted);
  margin-top:.5rem;
}
.comment-item time{
  display:block;
  font-size:.78rem;
  color:var(--muted);
  margin-top:.55rem;
}
.comment-item button{
  margin-top:.55rem;
  width:auto;
}
  .comment-empty{
    font-style:italic;
    color:var(--muted);
  }

  .network-banner{
    position:sticky;
    top:0;
    left:0;
    right:0;
    padding:.75rem 1rem;
    background:rgba(213,199,157,.9);
    color:var(--ink);
    text-align:center;
    font-weight:600;
    z-index:999;
    transition:opacity .2s ease;
  }

  .network-banner[hidden]{
    display:none !important;
  }

  .network-banner.loading{
    background:rgba(213,199,157,.95);
  }

  .network-banner.error{
    background:rgba(231,176,169,.95);
    color:#3b1111;
  }


  </style>
</head>
  
  <body>
  <div id="networkBanner" class="network-banner" hidden role="status" aria-live="polite"></div>
  <!-- Header + Disclaimer Section -->
  <header>
    <h1>The Oracle Trials: A Festival of Fate</h1>
    <div class="subtitle">Create your student adventurer for the winter one-shot competition.</div>
  </header>

  <div class="disclaimer">
    <strong>Disclaimer:</strong> A degree from the Oracle Academy does not guarantee immunity from fireballs, charm effects, or divine smiting. The faculty assumes no responsibility for polymorph accidents, summoned imps, or unforeseen time loops. Snacks are encouraged, hubris is not.
    </div>
    <main id="app-root">
  <div class="wizard">
    <div class="steps-shell" aria-label="Character builder steps">
      <div class="steps-header">
        <h3>Steps</h3>
        <small id="cfgBadge" class="muted"></small>
      </div>
      <nav id="stepNav" class="steps-rail" role="tablist" aria-label="Character builder steps"></nav>
    </div>

    <!-- JS renders each screen here -->
    <section id="panels" class="grid" style="gap:16px"></section>

    <div class="steps-actions card" aria-label="Quick actions">
      <div class="kicker">Quick actions</div>
      <div class="flex">
        <button id="btnSave">Save Draft</button>
        <button id="btnLoad">Load Draft</button>
        <button id="btnExport" class="primary">Export JSON</button>
        <button id="btnClear" class="danger">Clear Local Data</button>
      </div>
    </div>
  </div>
</main>

  <script>
  /* =======================
     CONSTANTS & STORES
  ======================= */
  const AVAIL_DATES = [
    '2025-12-21','2025-12-22','2025-12-23',
    '2025-12-26','2025-12-27','2025-12-28','2025-12-29',
    '2026-01-01'
  ];

  function resolveApiBase(){
    const cfg = window.APP_CONFIG || {};
    const configured = typeof cfg.apiBaseUrl === 'string' ? cfg.apiBaseUrl.trim() : '';
    if(configured){
      return configured;
    }
    const sameOrigin = (typeof window !== 'undefined' && window.location && window.location.origin)
      ? `${window.location.origin.replace(/\/$/, '')}/api`
      : '/api';
    console.warn('[OracleTournament] window.APP_CONFIG.apiBaseUrl is not configured; defaulting to', sameOrigin);
    window.APP_CONFIG = {...cfg, apiBaseUrl: sameOrigin};
    return sameOrigin;
  }

  const API_BASE = resolveApiBase();

  const PlayerIdentity = (()=>{
    const STORAGE_KEY = 'player_key';
    function read(){
      try{
        return (localStorage.getItem(STORAGE_KEY) || '').trim().toLowerCase();
      }catch(err){
        console.warn('Failed to read player key from storage', err);
        return '';
      }
    }
    function requireKey(){
      const key = read();
      if(!key){
        window.location.href = './login.html';
        throw new Error('Player key is required.');
      }
      return key;
    }
    function clear(){
      try{ localStorage.removeItem(STORAGE_KEY); }catch{}
    }
    function getRosterEntry(){
      const key = read();
      if(!key) return null;
      const roster = getRosterList({ includeHidden: true });
      return roster.find(entry => entry.key === key) || null;
    }
    return { getKey: read, requireKey, clear, getRosterEntry };
  })();

  const CURRENT_PLAYER_KEY = PlayerIdentity.requireKey();

  const DEFAULT_SHARED_STATE = {
    sessions: [],
    rosterExtras: [],
    rosterMeta: {},
    availability: {},
    buildCards: {}
  };

  function normalisePlayer(entry){
    if(!entry) return null;
    if(typeof entry === 'string'){
      const character = sanitizeName(entry);
      if(!character) return null;
      return { key: rosterKey(entry), character };
    }
    if(typeof entry !== 'object') return null;
    const character = sanitizeName(entry.character || entry.characterName || entry.name || entry.player_name || '');
    const keySource = entry.key || entry.playerKey || entry.player_key || entry.code || entry.id || character;
    const key = rosterKey(keySource);
    if(!key && !character){
      return null;
    }
    const playerName = sanitizeName(entry.playerName || entry.player_name || entry.displayName || '');
    return {
      key: key || rosterKey(character),
      character: character || playerName || key || '',
      playerName
    };
  }

  function normaliseSession(session){
    if(!session || typeof session !== 'object') return null;
    const id = String(session.id || '').trim();
    const title = sanitizeOptional(session.title) || (id ? `Session ${id}` : 'Session');
    const dm = sanitizeOptional(session.dm);
    const date = String(session.date || '').trim();
    const capacity = Number.isFinite(Number(session.capacity)) ? Number(session.capacity) : 0;
    const players = Array.isArray(session.players)
      ? session.players.map(normalisePlayer).filter(Boolean)
      : [];
    return {
      id,
      title,
      dm,
      date,
      capacity,
      finale: Boolean(session.finale),
      players
    };
  }

  function normaliseSharedState(input){
    const safe = {
      sessions: [],
      rosterExtras: [],
      rosterMeta: {},
      availability: {},
      buildCards: {}
    };

    if(!input || typeof input !== 'object'){
      return safe;
    }

    if(Array.isArray(input.sessions)){
      input.sessions.forEach((session)=>{
        const clean = normaliseSession(session);
        if(clean && clean.id){
          clean.players = Array.isArray(session.players)
            ? session.players.map(normalisePlayer).filter(Boolean)
            : [];
          safe.sessions.push(clean);
        }
      });
    }

    if(Array.isArray(input.rosterExtras)){
      input.rosterExtras.forEach((item)=>{
        if(!item || typeof item !== 'object') return;
        const name = sanitizeName(item.name);
        if(!name) return;
        const key = rosterKey(item.key || name);
        if(!key) return;
        safe.rosterExtras.push({
          key,
          name,
          status: sanitizeOptional(item.status),
          notes: sanitizeOptional(item.notes),
          custom: true
        });
      });
    }

    if(input.rosterMeta && typeof input.rosterMeta === 'object'){
      Object.entries(input.rosterMeta).forEach(([rawKey, value])=>{
        const key = rosterKey(rawKey);
        if(!key || !value || typeof value !== 'object') return;
        const status = sanitizeOptional(value.status);
        const notes = sanitizeOptional(value.notes);
        const hidden = Boolean(value.hidden);
        if(status || notes || hidden){
          safe.rosterMeta[key] = { status, notes, hidden };
        }
      });
    }

    if(input.availability && typeof input.availability === 'object'){
      Object.entries(input.availability).forEach(([rawKey, dates])=>{
        const key = rosterKey(rawKey);
        if(!key || !dates || typeof dates !== 'object') return;
        const row = {};
        Object.entries(dates).forEach(([date, value])=>{
          if(AVAIL_DATES.includes(date)){
            row[date] = Boolean(value);
          }
        });
        safe.availability[key] = row;
      });
    }

    if(input.buildCards && typeof input.buildCards === 'object'){
      Object.entries(input.buildCards).forEach(([rawKey, card])=>{
        const key = rosterKey(rawKey);
        if(!key || !card || typeof card !== 'object') return;
        const entry = {};
        if(card.class) entry.class = sanitizeOptional(card.class);
        if(card.university) entry.university = sanitizeOptional(card.university);
        if(card.characterName || card.character_name || card.name){
          entry.characterName = sanitizeName(card.characterName || card.character_name || card.name);
        }
        safe.buildCards[key] = entry;
      });
    }

    return safe;
  }

  const OfflineStateStore = {
    key: 'oracleOfflineState',
    read(){
      try{
        const raw = localStorage.getItem(this.key);
        if(!raw) return null;
        const parsed = JSON.parse(raw);
        if(parsed && typeof parsed === 'object' && parsed.version === 1 && parsed.state){
          return normaliseSharedState(parsed.state);
        }
      }catch(err){
        console.warn('Offline cache read failed', err);
      }
      return null;
    },
    write(state){
      try{
        localStorage.setItem(this.key, JSON.stringify({version:1, state}));
      }catch(err){
        console.warn('Offline cache write failed', err);
      }
    },
    clear(){
      try{ localStorage.removeItem(this.key); }catch{}
    }
  };

  const NetworkStatus = (function(){
    const banner = document.getElementById('networkBanner');
    let pending = 0;
    let lastError = '';

    function update(){
      if(!banner) return;
      if(lastError){
        banner.textContent = `⚠️ ${lastError}`;
        banner.classList.add('error');
        banner.classList.remove('loading');
        banner.hidden = false;
        return;
      }
      if(pending > 0){
        banner.textContent = 'Syncing with the Oracle Archives…';
        banner.classList.add('loading');
        banner.classList.remove('error');
        banner.hidden = false;
      } else {
        banner.hidden = true;
        banner.classList.remove('error');
        banner.classList.remove('loading');
      }
    }

    return {
      begin(){ pending++; update(); },
      end(){ pending = Math.max(0, pending - 1); update(); },
      setError(message){ lastError = message || 'Network request failed.'; update(); },
      clearError(){ lastError = ''; update(); }
    };
  })();

  function withApiBase(path){
    if(!API_BASE) return path;
    if(/^https?:/i.test(path)) return path;
    try{
      return new URL(path, API_BASE).toString();
    }catch{
      return API_BASE.replace(/\/$/, '') + path;
    }
  }

  async function apiFetch(path, options={}){
    const url = withApiBase(path);
    const opts = {...options};
    opts.headers = {...(options.headers||{})};
    if(opts.body && !(opts.body instanceof FormData) && !opts.headers['Content-Type']){
      opts.headers['Content-Type'] = 'application/json';
    }

    NetworkStatus.begin();
    try{
      const response = await fetch(url, opts);
      if(!response.ok){
        const text = await response.text();
        throw new Error(text || `Request failed (${response.status})`);
      }
      const contentType = response.headers.get('content-type') || '';
      let payload = null;
      if(contentType.includes('application/json')){
        payload = await response.json();
      } else {
        payload = await response.text();
      }
      NetworkStatus.clearError();
      return payload;
    }catch(err){
      NetworkStatus.setError(err && err.message ? err.message : 'Network request failed.');
      throw err;
    }finally{
      NetworkStatus.end();
    }
  }

  window.APP_UTILS = window.APP_UTILS || {};
  window.APP_UTILS.testApiConnection = async function testApiConnection(){
    const response = await apiFetch('/api/state', { headers:{ Accept:'application/json' } });
    console.info('[OracleTournament] /api/state responded with:', response);
    return response;
  };

  const SharedState = {
    data: normaliseSharedState(DEFAULT_SHARED_STATE),
    offline: true,
    fallback: normaliseSharedState(DEFAULT_SHARED_STATE),
    listeners: new Set(),
    apply(state, source='remote'){
      const normalised = normaliseSharedState(state);
      this.data = normalised;
      if(source === 'remote'){
        OfflineStateStore.write(normalised);
        this.offline = false;
      } else {
        this.offline = true;
        if(source === 'offline-cache'){
          OfflineStateStore.write(normalised);
        }
      }
      this.notify();
      return normalised;
    },
    useFallbackSessions(list){
      if(Array.isArray(list)){
        this.fallback.sessions = list.map((session)=>{
          const clean = normaliseSession(session);
          return clean ? {
            ...clean,
            players: Array.isArray(clean.players)
              ? clean.players.map(player => ({ ...player }))
              : []
          } : null;
        }).filter(Boolean);
      }
    },
    useDefaultFallback(){
      this.apply(this.fallback, 'offline-default');
    },
    loadFallbackFromCache(){
      const cached = OfflineStateStore.read();
      if(cached){
        this.apply(cached, 'offline-cache');
        return true;
      }
      return false;
    },
    async refresh(){
      try{
        const payload = await apiFetch('/api/state', { headers:{'Accept':'application/json'} });
        if(!payload || typeof payload !== 'object' || !payload.state){
          throw new Error('Invalid response from datastore.');
        }
        this.apply(payload.state, 'remote');
        return this.data;
      }catch(err){
        const hadCache = this.loadFallbackFromCache();
        if(!hadCache){
          this.useDefaultFallback();
        }
        throw err;
      }
    },
    subscribe(fn){
      if(typeof fn === 'function'){
        this.listeners.add(fn);
        try{ fn(this.data); }catch(err){ console.error(err); }
      }
      return ()=>this.listeners.delete(fn);
    },
    notify(){
      this.listeners.forEach((fn)=>{
        try{ fn(this.data); }catch(err){ console.error(err); }
      });
    },
    getSessionsCopy(){
      return this.data.sessions.map((session)=>({
        ...session,
        players: Array.isArray(session.players)
          ? session.players.map(player => ({ ...player }))
          : []
      }));
    }
  };

  const Backend = {
    async joinSession(sessionId, payload){
      const rosterEntry = PlayerIdentity.getRosterEntry();
      const body = {
        ...payload,
        playerKey: payload?.playerKey || CURRENT_PLAYER_KEY,
        playerName: payload?.playerName || rosterEntry?.name || '',
        characterName: payload?.characterName || payload?.name
      };
      const res = await apiFetch(`/api/sessions/${encodeURIComponent(sessionId)}/join`, {
        method:'POST',
        body: JSON.stringify(body)
      });
      if(res && res.state){
        SharedState.apply(res.state, 'remote');
      }
      return res;
    },
    async leaveSession(sessionId, payload){
      const body = {
        ...payload,
        playerKey: payload?.playerKey || CURRENT_PLAYER_KEY
      };
      const res = await apiFetch(`/api/sessions/${encodeURIComponent(sessionId)}/leave`, {
        method:'POST',
        body: JSON.stringify(body)
      });
      if(res && res.state){
        SharedState.apply(res.state, 'remote');
      }
      return res;
    },
    async setAvailability(payload){
      const rosterEntry = PlayerIdentity.getRosterEntry();
      const body = {
        ...payload,
        playerKey: payload?.playerKey || CURRENT_PLAYER_KEY,
        playerName: payload?.playerName || rosterEntry?.name || payload?.name
      };
      const res = await apiFetch('/api/availability', {
        method:'POST',
        body: JSON.stringify(body)
      });
      if(res && res.state){
        SharedState.apply(res.state, 'remote');
      }
      return res;
    },
    async addRosterExtra(payload){
      const res = await apiFetch('/api/roster/extras', {
        method:'POST',
        body: JSON.stringify(payload)
      });
      if(res && res.state){
        SharedState.apply(res.state, 'remote');
      }
      return res;
    },
    async updateRosterEntry(key, payload){
      const res = await apiFetch(`/api/roster/${encodeURIComponent(key)}`, {
        method:'PATCH',
        body: JSON.stringify(payload)
      });
      if(res && res.state){
        SharedState.apply(res.state, 'remote');
      }
      return res;
    },
    async removeRosterExtra(key){
      const res = await apiFetch(`/api/roster/extras/${encodeURIComponent(key)}`, {
        method:'DELETE'
      });
      if(res && res.state){
        SharedState.apply(res.state, 'remote');
      }
      return res;
    }
  };

  const AvailabilityStore = {
    read(){
      return SharedState.data.availability;
    }
  };

  const RosterExtrasStore = {
    read(){
      return SharedState.data.rosterExtras;
    }
  };

  const RosterMetaStore = {
    read(){
      return SharedState.data.rosterMeta;
    }
  };

  const HTML_ESCAPE = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" };

  function sanitizeName(value){
    return String(value ?? '').trim();
  }

  function sanitizeOptional(value){
    return String(value ?? '').trim();
  }

  function rosterKey(name){
    return sanitizeName(name).toLowerCase();
  }

  function escapeHTML(value){
    return String(value ?? '').replace(/[&<>"']/g, (ch)=>HTML_ESCAPE[ch]||ch);
  }

  function escapeAttr(value){
    return escapeHTML(value);
  }

  let BASE_ROSTER_KEYS = new Set();

  function rosterHasKey(key){
    const normalised = rosterKey(key);
    if(!normalised) return false;
    if(BASE_ROSTER_KEYS.has(normalised)) return true;
    return RosterExtrasStore.read().some(entry => entry.key === normalised);
  }

  async function addRosterExtra(name, status='', notes=''){
    const cleanName = sanitizeName(name);
    if(!cleanName) return {ok:false, msg:'Name is required.'};
    const key = rosterKey(cleanName);
    if(rosterHasKey(key)) return {ok:false, msg:`${cleanName} is already on the roster.`};
    const cleanStatus = sanitizeOptional(status);
    const cleanNotes = sanitizeOptional(notes);
    try{
      await Backend.addRosterExtra({ name: cleanName, status: cleanStatus, notes: cleanNotes });
      return {ok:true, key, name: cleanName};
    }catch(err){
      return {ok:false, msg: err && err.message ? err.message : 'Failed to add roster entry.'};
    }
  }

  async function updateRosterDetails(key, entry, status, notes, hiddenOverride){
    const cleanKey = rosterKey(key);
    if(!cleanKey) return;
    const cleanStatus = sanitizeOptional(status);
    const cleanNotes = sanitizeOptional(notes);
    const hidden = hiddenOverride == null ? Boolean(entry && entry.hidden) : Boolean(hiddenOverride);
    await Backend.updateRosterEntry(cleanKey, {
      status: cleanStatus,
      notes: cleanNotes,
      custom: Boolean(entry && entry.custom),
      name: entry && entry.name ? sanitizeName(entry.name) : '',
      hidden
    });
  }

  async function setRosterHidden(entry, hidden){
    if(!entry || !entry.key) return;
    await updateRosterDetails(entry.key, entry, entry.status, entry.notes, hidden);
  }

  async function removeRosterExtra(key){
    const cleanKey = rosterKey(key);
    if(!cleanKey) return;
    await Backend.removeRosterExtra(cleanKey);
  }

  function getRosterList(opts={}){
    const includeHidden = Boolean(opts.includeHidden);
    const extras = RosterExtrasStore.read();
    const meta = RosterMetaStore.read();
    const list = [];

    DATA.roster.forEach((r)=>{
      const key = rosterKey(r.key || r.name);
      const override = meta[key] || {};
      const entry = {
        name: r.name,
        key,
        status: override.status || sanitizeOptional(r.status),
        notes: override.notes || sanitizeOptional(r.notes),
        custom: false,
        hidden: Boolean(override.hidden)
      };
      if(entry.hidden && !includeHidden){
        return;
      }
      list.push(entry);
    });

    extras.forEach((item)=>{
      const key = rosterKey(item.key || item.name);
      const override = meta[key] || {};
      const entry = {
        name: item.name,
        key,
        status: override.status || sanitizeOptional(item.status),
        notes: override.notes || sanitizeOptional(item.notes),
        custom: true,
        hidden: Boolean(override.hidden)
      };
      if(entry.hidden && !includeHidden){
        return;
      }
      list.push(entry);
    });

    return list.sort((a,b)=>a.name.localeCompare(b.name,'en',{sensitivity:'base'}));
  }

  function getHiddenRosterEntries(){
    return getRosterList({ includeHidden: true }).filter(entry => entry.hidden);
  }

  function labelDate(iso){
    try{
      const dt = new Date(iso + 'T00:00:00');
      return dt.toLocaleDateString('en-CA',{month:'short', day:'2-digit'}); // e.g., Dec 21
    }catch{ return iso; }
  }

  function toLocalICS(dt){
    const pad = n => String(n).padStart(2,'0');
    return dt.getFullYear()+pad(dt.getMonth()+1)+pad(dt.getDate())+'T'+pad(dt.getHours())+pad(dt.getMinutes())+pad(dt.getSeconds());
  }

  function downloadICS(session){
    const tz = 'America/Edmonton';
    // default 7–9pm local
    const start = new Date(session.date + 'T19:00:00');
    const end   = new Date(session.date + 'T21:00:00');
    const uid = `${session.id}@oracletrials`;
    const ics = [
      'BEGIN:VCALENDAR','VERSION:2.0','PRODID:-//OracleTrials//Scheduler//EN','CALSCALE:GREGORIAN','METHOD:PUBLISH','BEGIN:VEVENT',
      `UID:${uid}`,
      `SUMMARY:${session.title}`,
      `DESCRIPTION:DM: ${session.dm} | Capacity: ${session.capacity}`,
      `DTSTART;TZID=${tz}:${toLocalICS(start)}`,
      `DTEND;TZID=${tz}:${toLocalICS(end)}`,
      'END:VEVENT','END:VCALENDAR'
    ].join('\r\n');
    const blob = new Blob([ics], {type:'text/calendar'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `${session.title.replace(/\s+/g,'-')}.ics`;
    a.click();
    URL.revokeObjectURL(a.href);
  }

  /* =======================
     DATA
  ======================= */
  const DATA = {
    levels:[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],
    abilityArrays:{ standard:[15,14,13,12,10,8] },
    universities:[
      { key:'lorehold', name:'Lorehold', theme:'History & Spirits', colours:'Red/White', focus:'Archaeomancy', playstyle:'Scholar / Explorer', spells:{
          1:['Comprehend Languages','Identify'],
          2:['Borrowed Knowledge','Locate Object'],
          3:['Speak with Dead','Spirit Guardians'],
          4:['Arcane Eye','Stone Shape'],
          5:['Flame Strike','Legend Lore']
      }},
      { key:'prismari', name:'Prismari', theme:'Elemental Arts', colours:'Blue/Red', focus:'Performance & Elements', playstyle:'Passion / Spectacle', spells:{
          1:['Chromatic Orb','Thunderwave'],
          2:['Flaming Sphere','Kinetic Jaunt'],
          3:['Haste','Water Walk'],
          4:['Freedom of Movement','Wall of Fire'],
          5:['Cone of Cold','Conjure Elemental']
      }},
      { key:'quandrix', name:'Quandrix', theme:'Math & Nature', colours:'Blue/Green', focus:'Fractals / Growth', playstyle:'Logical / Curious', spells:{
          1:['Entangle','Guiding Bolt'],
          2:['Enlarge/Reduce','Vortex Warp'],
          3:['Aura of Vitality','Haste'],
          4:['Control Water','Freedom of Movement'],
          5:['Circle of Power','Passwall']
      }},
      { key:'silverquill', name:'Silverquill', theme:'Eloquence & Ink', colours:'White/Black', focus:'Radiance & Shadow', playstyle:'Charisma / Wit', spells:{
          1:['Dissonant Whispers','Silvery Barbs'],
          2:['Calm Emotions','Darkness'],
          3:['Beacon of Hope','Daylight'],
          4:['Compulsion','Confusion'],
          5:['Dominate Person','Rary’s Telepathic Bond']
      }},
      { key:'witherbloom', name:'Witherbloom', theme:'Life & Decay', colours:'Green/Black', focus:'Alchemy / Essence', playstyle:'Healer / Witch', spells:{
          1:['Cure Wounds','Inflict Wounds'],
          2:['Lesser Restoration','Wither and Bloom'],
          3:['Revivify','Vampiric Touch'],
          4:['Blight','Death Ward'],
          5:['Antilife Shell','Greater Restoration']
      }}
    ],
    backgrounds:[
      {key:'lorehold-student', name:'Lorehold Student', skills:['History','Religion'], tools:[], languages:'2 of choice', gear:['Ink/pen','Hammer','Lantern','History tome','Uniform'], feat:'Strixhaven Initiate (Lorehold)'},
      {key:'prismari-student', name:'Prismari Student', skills:['Acrobatics','Performance'], tools:['+1 instrument/tool'], languages:'1', gear:['Ink/pen','Artisan tools or Instrument','Uniform'], feat:'Strixhaven Initiate (Prismari)'},
      {key:'quandrix-student', name:'Quandrix Student', skills:['Arcana','Nature'], tools:['+1 artisan tool'], languages:'1', gear:['Ink/pen','Abacus','Arcane theory book','Uniform'], feat:'Strixhaven Initiite (Silverquill)'},
      {key:'silverquill-student', name:'Silverquill Student', skills:['Intimidation','Persuasion'], tools:[], languages:'2', gear:['Ink/pen','Poetry book','Uniform'], feat:'Strixhaven Initiite (Silverquill)'},
      {key:'witherbloom-student', name:'Witherbloom Student', skills:['Nature','Survival'], tools:['Herbalism Kit'], languages:'1', gear:['Plant ID book','Iron pot','Herbalism kit','Uniform'], feat:'Strixhaven Initiate (Witherbloom)'}
    ],
    feats:{
      strixhavenInitiate:{
        name:'Strixhaven Initiate',
        text:'Choose your college; learn 2 cantrips from its list + one 1st-level spell. Cast the 1st-level spell once per long rest without a slot; also with slots. Choose Int/Wis/Cha as spellcasting ability for these.'
      }
    },
    extracurriculars:[
      {key:'dead-languages', name:'Dead Languages Society', skills:['Athletics','History']},
      {key:'fine-artists', name:'Distinguished Society of Fine Artists', skills:['Performance','Sleight of Hand']},
      {key:'dragonchess', name:'Dragonchess Club', skills:['Deception','Investigation']},
      {key:'historical-soc', name:'Dragonsguard Historical Society', skills:['Arcana','History']},
      {key:'horticulture', name:'Fantastical Horticulture Club', skills:['Nature','Survival']},
      {key:'entrepreneurs', name:'Future Entrepreneurs of Strixhaven', skills:['Insight','Persuasion']},
      {key:'gymnastics', name:'Intramural Gymnastics', skills:['Acrobatics','Performance']},
      {key:'silkball', name:'Silkball Club', skills:['Athletics','Intimidation']},
      {key:'water-dance', name:'Water-Dancing Club', skills:['Athletics','Performance']},
      {key:'larp', name:'LARP Guild', skills:['Animal Handling','Performance']},
      {key:'cheer', name:'Mage Tower Cheer', skills:['Perception','Persuasion']},
      {key:'drama', name:'Playactors Drama Guild', skills:['Arcana','Deception']},
      {key:'iron-lifters', name:'Iron-Lifters', skills:['Athletics','Medicine']},
      {key:'show-band', name:'Show Band', skills:['Sleight of Hand','Performance']},
      {key:'newspaper', name:'Strixhaven Star (Newspaper)', skills:['Investigation','Insight']},
      {key:'faith', name:'Student-Mages of Faith', skills:['Insight','Religion']}
    ],
    jobs:[
      {key:'biblioplex', name:'Biblioplex', skills:['Arcana','History']},
      {key:'firejolt', name:'Firejolt Café', skills:['Insight','Persuasion']},
      {key:'bowsend', name:"Bow's End Tavern", skills:['Performance','Deception']},
      {key:'stadium', name:'Stadium', skills:['Athletics','Intimidation']},
      {key:'performing-arts', name:'Performing Arts Society', skills:['Performance','Deception']},
      {key:'dorms', name:'Dormitories', skills:['Persuasion','Perception']},
      {key:'grounds', name:'Campus Grounds', skills:['Nature','Survival']},
      {key:'labs', name:'Magic Labs', skills:['Arcana','Investigation']},
      {key:'intramural', name:'Intramural Fields', skills:['Athletics','Acrobatics']}
    ],
    roster:[
      {name:'Amy', status:'Yes', key:'amy456'},
      {name:'Kaela', status:'Yes', key:'kaela123'},
      {name:'Trevor', status:'Yes', key:'trev789'}
    ],
    sessions:[
      {id:'s1', date:'2025-12-21', title:'Session 01', dm:'Kaela & Tory', capacity:6, players:[]},
      {id:'s2', date:'2025-12-22', title:'Session 02', dm:'Kaela & Tory', capacity:6, players:[]},
      {id:'s3', date:'2025-12-26', title:'Session 03', dm:'Kaela & Tory', capacity:6, players:[]},
      {id:'s4', date:'2025-12-27', title:'Session 04', dm:'Kaela & Tory', capacity:6, players:[]},
      {id:'s5', date:'2025-12-28', title:'Session 05', dm:'Kaela & Tory', capacity:6, players:[]},
      {id:'s6', date:'2025-12-29', title:'Session 06', dm:'Kaela & Tory', capacity:6, players:[]},
      {id:'finale', date:'2026-01-01', title:'Grand Finale', dm:'Kaela & Tory', capacity:8, players:[], finale:true}
    ]
  };

  // Always render roster A→Z without risk to source order
  DATA.roster = [...DATA.roster].sort((a,b)=>a.name.localeCompare(b.name,'en'));
  BASE_ROSTER_KEYS = new Set(DATA.roster.map(r=>rosterKey(r.key || r.name)));

  SharedState.useFallbackSessions(DATA.sessions);
  SharedState.useDefaultFallback();

  // Optional quick rule examples
  const ELIGIBILITY = {
    hardNo: [ 'Link' ],
    blockedDates: { 'Melissa': ['2025-12-28'] }
  };

  /* =======================
     VALIDATION & ERROR HANDLING
  ======================= */
  function validateConfig(){
    const errors=[];
    try{
      if(!Array.isArray(AVAIL_DATES)) errors.push('AVAIL_DATES is missing or not an array.');
      else AVAIL_DATES.forEach((d,i)=>{ if(!/^\d{4}-\d{2}-\d{2}$/.test(String(d))) errors.push(`AVAIL_DATES[${i}] must be YYYY-MM-DD (got "${d}")`); });
    }catch{ errors.push('AVAIL_DATES could not be read.'); }

    try{
      if(!Array.isArray(DATA.sessions)) errors.push('DATA.sessions is missing or not an array.');
      else{
        const ids=new Set();
        DATA.sessions.forEach((s,idx)=>{
          if(!s || typeof s!=='object'){ errors.push(`sessions[${idx}] is not an object`); return; }
          if(!s.id) errors.push(`sessions[${idx}] is missing an id`);
          if(s.id){ if(ids.has(s.id)) errors.push(`Duplicate session id: ${s.id}`); else ids.add(s.id); }
          if(!/^\d{4}-\d{2}-\d{2}$/.test(String(s.date||''))) errors.push(`${s.title||s.id||('session#'+idx)} has non-ISO date "${s.date}"`);
          if(typeof s.capacity !== 'number') errors.push(`${s.title||s.id||('session#'+idx)} capacity must be a number`);
        });
      }
    }catch{ errors.push('DATA.sessions could not be validated.'); }

    try{ if(!Array.isArray(DATA.roster)) errors.push('DATA.roster is missing or not an array.'); }
    catch{ errors.push('DATA.roster could not be validated.'); }

    return errors;
  }

  function showErrors(errors){
    if(!errors || !errors.length) return;
    const main=document.querySelector('main');
    const box=document.createElement('div');
    box.className='panel';
    box.style.border='1px solid #f14a3b';
    box.style.background='#1d1111';
    box.innerHTML = `
      <h2>Configuration issues</h2>
      <p>Fix the items below, then refresh. If you changed dates/IDs recently, hit <strong>Clear Local Data</strong> in the sidebar.</p>
      <ul>${errors.map(e=>`<li>${e.replace(/</g,'&lt;').replace(/>/g,'&gt;')}</li>`).join('')}</ul>
    `;
    main.prepend(box);
  }

  window.addEventListener('error', (e)=>{
    const main=document.querySelector('main');
    if(!main) return;
    const box=document.createElement('div');
    box.className='panel';
    box.style.border='1px solid #f14a3b';
    box.style.background='#1d1111';
    box.innerHTML=`<strong>Runtime error:</strong> ${String(e.message||'Unknown error')}`;
    main.prepend(box);
  });

  /* =======================
     STATE
  ======================= */
  const State = {
    data:{
      meta:{version:'0.5-stable'},
      core:{ playerName:'', name:'', race:'', class:'', background:'', level:4, abilityMethod:'standard', abilities:{STR:15,DEX:14,CON:13,INT:12,WIS:10,CHA:8}, equipment:'class'},
      university:{ key:'', spellAbility:'INT' },
      feats:[],
      extras:{ job:null, clubs:[], studentDice:[] },
      personality:{ traits:'', ideal:'', bond:'', rival:'', goal:'', prompt:'' },
      exams:{ notes:'', studyRerolls:0, results:[] }
    },
    sessions: [],
    save(){ localStorage.setItem('oracleTrialsSave', JSON.stringify(this.data)); alert('Draft saved to your browser.'); },
    load(){ const raw=localStorage.getItem('oracleTrialsSave'); if(!raw){alert('No save found.');return;} this.data=JSON.parse(raw); renderAll(); alert('Draft loaded.'); },
    export(){ const blob=new Blob([JSON.stringify({character:this.data, sessions:this.sessions},null,2)],{type:'application/json'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`oracle-trials-${(this.data.core.name||'character').toLowerCase().replace(/[^a-z0-9\-]/g,'-')}.json`; a.click(); URL.revokeObjectURL(url); }
  };

  SharedState.subscribe(()=>{
    State.sessions = SharedState.getSessionsCopy();
    if(State?.data?.core){
      const rosterEntry = PlayerIdentity.getRosterEntry();
      if(rosterEntry && !State.data.core.playerName){
        State.data.core.playerName = rosterEntry.name;
      }
    }
  });

  /* =======================
     HELPERS
  ======================= */
    
function buildReady() {
  const c = State.data.core || {};
  const uni = State.data.university || {};
  return Boolean(
    (c.name && c.name.trim().length >= 2) &&
    (c.class && c.class.trim()) &&
    (c.level && Number.isFinite(+c.level)) &&
    (uni.key && uni.key.trim())
  );
}


// Reusable card list
function renderSessionCards(container, opts={readOnly:false}){
  const {readOnly=false} = opts;
  container.innerHTML = '';
  const builds = SharedState.data.buildCards || {};

  State.sessions
    .slice()
    .sort((a,b)=>a.date.localeCompare(b.date))
    .forEach(s=>{
      const filled = (s.players||[]).length;
      const full = filled>=s.capacity;
      const roster = filled
        ? (Array.isArray(s.players) ? s.players : []).map(player=>{
            const b = player && player.key ? builds[player.key] : null;
            let extra = '';
            if(b){
              const classLabel = escapeHTML(b.class || '?');
              const uniLabel = escapeHTML(b.university || '?');
              extra = ` — <span class="muted">${classLabel} • ${uniLabel}</span>`;
            }
            const label = escapeHTML(player && (player.character || player.name || player.playerName || 'Player'));
            return `<div class="pill"><span>${label}</span>${extra}</div>`;
          }).join('')
        : '<span class="muted">No players yet</span>';

      const joinDisabled = (!buildReady() || full) ? 'disabled' : '';
      const joinBtn = readOnly ? '' : `<button data-id="${s.id}" class="primary" ${joinDisabled}>Add my character</button>`;

      const card = document.createElement('div'); card.className='card';
      card.innerHTML = `
        <div class="flex" style="justify-content:space-between">
          <div>
            <strong>${s.title}</strong>
            <div class="muted">${s.date} • DM: ${s.dm} • Capacity: ${filled}/${s.capacity}</div>
            <div class="muted" style="margin-top:4px">No duplicate universities allowed in the same session.</div>
            ${(!readOnly && !buildReady()) ? `<div class="muted" style="margin-top:6px">Finish <em>Core 5e</em> + choose a <em>University</em> to join.</div>` : ''}
            ${(!readOnly && full) ? `<div class="muted" style="margin-top:6px">This session is full.</div>` : ''}
          </div>
          <div class="flex">
            ${joinBtn}
            <button data-ics="${s.id}">.ics</button>
          </div>
        </div>
        <div style="margin-top:8px" class="flex">${roster}</div>
      `;
      container.appendChild(card);
    });
}

function setupCommentBoard(root){
  const form = root.querySelector('#commentForm');
  const textarea = root.querySelector('#commentText');
  const playerInput = root.querySelector('#commentPlayer');
  const characterInput = root.querySelector('#commentCharacter');
  const sessionInput = root.querySelector('#commentSession');
  const list = root.querySelector('#commentList');
  const refreshBtn = root.querySelector('#refreshComments');
  const status = root.querySelector('#commentStatus');
  if(!form || !textarea || !list) return;

  let statusTimer = 0;
  const submitButton = form.querySelector('button[type="submit"]');

  const announce = (message, tone='success')=>{
    if(!status) return;
    try{ window.clearTimeout(statusTimer); }catch{}
    status.textContent = message;
    status.dataset.tone = tone;
    status.hidden = false;
    statusTimer = window.setTimeout(()=>{ status.hidden = true; }, 3600);
  };

  if(status){
    status.hidden = true;
  }

  const formatStamp = (iso)=>{
    try{
      const date = new Date(iso);
      return date.toLocaleString(undefined, {
        month:'short', day:'numeric',
        hour:'numeric', minute:'2-digit'
      });
    }catch{
      return iso;
    }
  };

  const sortComments = (entries)=> entries.slice().sort((a, b)=>{
    const aTime = new Date(a?.createdAt || 0).getTime();
    const bTime = new Date(b?.createdAt || 0).getTime();
    return bTime - aTime;
  });

  const normaliseComment = (input)=>{
    if(!input || typeof input !== 'object') return null;
    const baseId = (input.id ?? input.comment_id ?? '').toString().trim();
    const textValue = (input.comment ?? input.text ?? '').toString().trim();
    if(!textValue){
      return null;
    }
    const playerName = sanitizeOptional(input.playerName ?? input.player_name);
    const characterName = sanitizeOptional(input.characterName ?? input.character_name);
    const sessionId = sanitizeOptional(input.sessionId ?? input.session_id);
    let createdAt = input.createdAt || input.created_at || input.stamp;
    if(createdAt){
      const stamp = new Date(createdAt);
      createdAt = Number.isNaN(stamp.getTime()) ? new Date().toISOString() : stamp.toISOString();
    }else{
      createdAt = new Date().toISOString();
    }
    const id = baseId || `local-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    return {
      id,
      playerName,
      characterName,
      sessionId,
      comment: textValue,
      createdAt
    };
  };

  const state = {
    comments: [],
    loading: false
  };

  const setComments = (entries)=>{
    const seen = new Set();
    const cleaned = [];
    (entries || []).forEach((entry)=>{
      const normalised = entry && entry.comment ? entry : normaliseComment(entry);
      if(!normalised || !normalised.comment){
        return;
      }
      if(seen.has(normalised.id)){
        return;
      }
      seen.add(normalised.id);
      cleaned.push(normalised);
    });
    state.comments = sortComments(cleaned);
    return state.comments;
  };

  const renderList = ()=>{
    if(state.loading){
      list.innerHTML = '<p class="comment-empty">Loading comments…</p>';
      return;
    }
    if(!state.comments.length){
      list.innerHTML = '<p class="comment-empty">No comments yet. Add the first note above.</p>';
      return;
    }
    list.innerHTML = '';
    state.comments.forEach((entry)=>{
      if(!entry || !entry.comment) return;
      const item = document.createElement('div');
      item.className = 'comment-item';
      item.dataset.pending = entry.pending ? 'true' : 'false';

      const copy = document.createElement('p');
      copy.textContent = entry.comment;
      item.appendChild(copy);

      if(entry.playerName || entry.characterName || entry.sessionId){
        const meta = document.createElement('div');
        meta.className = 'comment-meta';
        if(entry.playerName){
          const span = document.createElement('span');
          span.textContent = `Player: ${entry.playerName}`;
          meta.appendChild(span);
        }
        if(entry.characterName){
          const span = document.createElement('span');
          span.textContent = `Character: ${entry.characterName}`;
          meta.appendChild(span);
        }
        if(entry.sessionId){
          const span = document.createElement('span');
          span.textContent = `Session: ${entry.sessionId}`;
          meta.appendChild(span);
        }
        item.appendChild(meta);
      }

      const stamp = document.createElement('time');
      stamp.dateTime = entry.createdAt;
      stamp.textContent = formatStamp(entry.createdAt);
      item.appendChild(stamp);

      const remove = document.createElement('button');
      remove.type = 'button';
      remove.className = 'danger';
      if(entry.pending){
        remove.textContent = 'Posting…';
        remove.disabled = true;
      }else{
        remove.textContent = 'Delete';
        remove.addEventListener('click', ()=>{
          void handleDelete(entry);
        });
      }
      item.appendChild(remove);

      list.appendChild(item);
    });
  };

  const fetchComments = async ({ silent = false } = {})=>{
    state.loading = true;
    renderList();
    try{
      const payload = await apiFetch('/api/comments', { headers:{ Accept:'application/json' } });
      const rows = Array.isArray(payload?.comments) ? payload.comments : [];
      setComments(rows.map(normaliseComment).filter(Boolean));
      if(!silent){
        announce('Comments updated.', 'info');
      }
    }catch(err){
      if(!silent){
        announce(err && err.message ? err.message : 'Failed to load comments.', 'error');
      }
      throw err;
    }finally{
      state.loading = false;
      renderList();
    }
  };

  const handleDelete = async (entry)=>{
    if(!entry || !entry.id) return;
    const ok = (typeof confirm === 'function') ? confirm('Delete this comment?') : true;
    if(!ok) return;
    const previous = state.comments.slice();
    setComments(previous.filter((item)=> item.id !== entry.id));
    renderList();
    announce('Removing comment…', 'info');
    try{
      await apiFetch(`/api/comments/${encodeURIComponent(entry.id)}`, { method:'DELETE' });
      announce('Comment deleted.', 'info');
    }catch(err){
      setComments(previous);
      renderList();
      announce(err && err.message ? err.message : 'Failed to delete comment.', 'error');
    }
  };

  form.addEventListener('submit', async (event)=>{
    event.preventDefault();
    const textValue = (textarea.value || '').trim();
    if(!textValue){
      announce('Comment text is required.', 'error');
      return;
    }

    const playerName = playerInput ? sanitizeOptional(playerInput.value) : '';
    const characterName = characterInput ? sanitizeOptional(characterInput.value) : '';
    const sessionId = sessionInput ? sanitizeOptional(sessionInput.value) : '';

    const previous = state.comments.slice();
    const optimistic = {
      id: `pending-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
      playerName,
      characterName,
      sessionId,
      comment: textValue,
      createdAt: new Date().toISOString(),
      pending: true
    };

    setComments([optimistic, ...previous]);
    renderList();
    announce('Posting comment…', 'info');
    if(submitButton){
      submitButton.disabled = true;
    }

    try{
      const response = await apiFetch('/api/comments', {
        method:'POST',
        body: JSON.stringify({
          playerName,
          characterName,
          sessionId,
          comment: textValue
        })
      });
      const saved = normaliseComment(response && response.comment);
      if(!saved){
        throw new Error('Invalid response from datastore.');
      }
      setComments([saved, ...previous]);
      renderList();
      if(textarea){ textarea.value = ''; }
      if(playerInput){ playerInput.value = ''; }
      if(characterInput){ characterInput.value = ''; }
      if(sessionInput){ sessionInput.value = ''; }
      announce('Comment posted!', 'success');
    }catch(err){
      setComments(previous);
      renderList();
      if(err && err.message){
        announce(err.message, 'error');
      }else{
        announce('Failed to post comment.', 'error');
      }
    }finally{
      if(submitButton){
        submitButton.disabled = false;
      }
    }
  });

  if(refreshBtn){
    refreshBtn.addEventListener('click', (event)=>{
      event.preventDefault();
      fetchComments().catch((err)=>{
        if(err && err.message){
          announce(err.message, 'error');
        }else{
          announce('Failed to refresh comments.', 'error');
        }
      });
    });
  }

  renderList();
  fetchComments({ silent: true }).catch((err)=>{
    if(err && err.message){
      announce(err.message, 'error');
    }else{
      announce('Unable to load comments.', 'error');
    }
  });
}

async function hydrateQuestBoard(root=document){
  const container = root?.querySelector?.('#questList');
  if(!container) return;

  container.innerHTML = '<p class="muted">Loading quests…</p>';

  try{
    const response = await fetch('./site/data/quests.json', {cache:'no-store'});
    if(!response.ok) throw new Error(`Request failed: ${response.status}`);

    const quests = await response.json();
    if(!Array.isArray(quests) || !quests.length){
      container.innerHTML = '<p class="muted">No quests are published yet. Check back soon.</p>';
      return;
    }

    const frag = document.createDocumentFragment();
    quests.forEach((quest)=>{
      if(!quest || typeof quest !== 'object') return;
      const card = document.createElement('article');
      card.className = 'quest-card';

      const title = document.createElement('h4');
      title.textContent = quest.title || `Quest #${quest.id ?? '?'}`;
      card.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'quest-meta';

      if(typeof quest.id !== 'undefined'){
        const idSpan = document.createElement('span');
        idSpan.textContent = `ID ${quest.id}`;
        meta.appendChild(idSpan);
      }

      if(quest.status){
        const statusSpan = document.createElement('span');
        statusSpan.textContent = `Status: ${quest.status}`;
        meta.appendChild(statusSpan);
      }

      if(meta.childNodes.length){
        card.appendChild(meta);
      }

      if(quest.notes){
        const notes = document.createElement('p');
        notes.className = 'quest-notes';
        notes.textContent = quest.notes;
        card.appendChild(notes);
      }

      frag.appendChild(card);
    });

    container.innerHTML = '';
    container.appendChild(frag);
  }catch(err){
    console.error('Quest board failed', err);
    container.innerHTML = '<p class="muted">Unable to load quests right now. Try refreshing later.</p>';
  }
}

  function getBuildCards(){
    return SharedState.data.buildCards || {};
  }

  function getCurrentCharacterName(){
    const fromState = (State.data?.core?.name||'').trim();
    if(fromState) return fromState;
    const input = document.querySelector('#core_name');
    return (input?.value||'').trim();
  }

  function canJoinSession(session, name){
    const thisUni = (DATA.universities.find(u=>u.key===State.data?.university?.key)?.name) || '';
    if(!thisUni) return {ok:false, msg:'Pick a University in step 4 first.'};
    const players = Array.isArray(session.players) ? session.players : [];
    const cards = getBuildCards();
    for(const entry of players){
      const b = entry && entry.key ? cards[entry.key] : null;
      if(b && b.university && b.university === thisUni){
        return {ok:false, msg:`Another ${thisUni} student is already in this session. Choose a different session or college.`};
      }
    }
    return {ok:true};
  }

function downloadAvailabilityCSV() {
  const avail = AvailabilityStore.read();
  const dates = AVAIL_DATES.slice();                 // ISO strings
  const header = ["name", ...dates.map(labelDate)];  // labelDate → "Dec 21" etc.

  const rows = [header];

  getRosterList().forEach(r => {
    const line = [r.name];
    dates.forEach(d => {
      const row = avail[r.key] || {};
      line.push(row[d] ? "Y" : "");      // "Y" if available, blank if not
    });
    rows.push(line);
  });

  const csv = rows.map(r => r.map(x =>
    `"${String(x ?? "").replaceAll('"','""')}"`
  ).join(",")).join("\n");

  const stamp = new Date().toISOString().slice(0,10).replace(/-/g,"");
  const blob = new Blob([csv], { type: "text/csv" });
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = `oracle-availability-${stamp}.csv`;
  a.click();
  URL.revokeObjectURL(a.href);
}


  /* =======================
     STEPS
  ======================= */
const STEPS = [
  {key:'intro',       title:'Welcome',                hint:'Overview & updates'},
  {key:'sessions',    title:'Availability',           hint:'Mark who can attend'},
  {key:'core',        title:'Core 5e Setup',          hint:'Stats, species, class'},
  {key:'university',  title:'University & Feat',      hint:'Select your college'},
  {key:'extras',      title:'Job & Extracurriculars', hint:'Schedule & flavour'},
  {key:'personality', title:'Personality & Prompt',   hint:'Backstory beats'},
  {key:'join',        title:'Join a Session',         hint:'Reserve a seat'},
  {key:'summary',     title:'Summary & Export',       hint:'Share or download'}
];



  let currentStep = 0;

  function focusCurrentTab(){
    const nav = document.getElementById('stepNav');
    if(!nav) return;
    const active = nav.querySelector('button[aria-selected="true"]');
    if(active){
      active.focus();
    }
  }

  function activateStep(idx, focusTab = false){
    if(Number.isNaN(idx) || idx < 0 || idx >= STEPS.length){
      return;
    }
    currentStep = idx;
    renderPanels();
    renderNav();
    if(focusTab){
      focusCurrentTab();
    }
  }

  function onStepRailKeydown(event){
    const target = event.target;
    if(!target || target.getAttribute('role') !== 'tab'){ return; }
    const key = event.key;
    const currentIndex = Number(target.dataset.index || '0');
    let nextIndex = null;
    if(key === 'ArrowRight' || key === 'ArrowDown'){
      nextIndex = (currentIndex + 1) % STEPS.length;
    } else if(key === 'ArrowLeft' || key === 'ArrowUp'){
      nextIndex = (currentIndex - 1 + STEPS.length) % STEPS.length;
    } else if(key === 'Home'){
      nextIndex = 0;
    } else if(key === 'End'){
      nextIndex = STEPS.length - 1;
    }
    if(nextIndex !== null){
      event.preventDefault();
      activateStep(nextIndex, true);
    }
  }

  function renderNav(){
    const nav = document.getElementById('stepNav');
    if(!nav) return;

    const previousScroll = nav.scrollLeft;
    nav.innerHTML = '';
    nav.setAttribute('role', 'tablist');
    nav.setAttribute('aria-label', 'Character builder steps');

    const fragments = document.createDocumentFragment();
    STEPS.forEach((s, idx)=>{
      const button = document.createElement('button');
      button.type = 'button';
      button.id = `step-tab-${s.key}`;
      button.className = 'step-pill';
      button.dataset.step = s.key;
      button.dataset.index = String(idx);
      button.setAttribute('role', 'tab');
      button.setAttribute('aria-controls', `panel-${s.key}`);
      const selected = idx === currentStep;
      button.setAttribute('aria-selected', selected ? 'true' : 'false');
      button.setAttribute('tabindex', selected ? '0' : '-1');
      const hint = s.hint ? `<small>${escapeHTML(s.hint)}</small>` : '';
      button.innerHTML = `
        <span class="step-number">${idx + 1}</span>
        <span class="step-label"><span>${escapeHTML(s.title)}</span>${hint}</span>
      `;
      button.addEventListener('click', ()=>{
        activateStep(idx, true);
      });
      fragments.appendChild(button);
    });
    nav.appendChild(fragments);

    if(!nav.dataset.keysBound){
      nav.addEventListener('keydown', onStepRailKeydown);
      nav.dataset.keysBound = 'true';
    }

    if(nav.scrollWidth > nav.clientWidth + 8){
      const active = nav.querySelector('button[aria-selected="true"]');
      if(active){
        try{
          active.scrollIntoView({block:'nearest', inline:'center'});
        }catch{
          /* ignore */
        }
      }
    }else{
      nav.scrollLeft = previousScroll;
    }

    const badge=document.getElementById('cfgBadge');
    const errs=validateConfig();
    badge.textContent = errs.length? `⚠️ ${errs.length} config issue${errs.length>1?'s':''}` : '✅ config OK';
  }

  function renderPanels(){
    const el = document.getElementById('panels');
    if(!el) return;
    el.innerHTML='';
    const step = STEPS[currentStep].key;
    let panelEl = null;
    if(step==='core') panelEl = panelCore();
    if(step==='university') panelEl = panelUniversity();
    if(step==='extras') panelEl = panelExtras();
    if(step==='sessions') panelEl = panelSessions();
    if(step==='personality') panelEl = panelPersonality();
    if(step==='summary') panelEl = panelSummary();
    if(step==='intro') panelEl = panelIntro();
    if(step==='join') panelEl = panelJoin();
    if(panelEl){
      panelEl.id = `panel-${step}`;
      panelEl.setAttribute('role','tabpanel');
      panelEl.setAttribute('aria-labelledby', `step-tab-${step}`);
      panelEl.setAttribute('tabindex','0');
      el.appendChild(panelEl);
    }

  }

  /* =======================
     PANELS
  ======================= */
function panelIntro(){
  const p = document.createElement('div');
  p.className = 'panel';
  p.innerHTML = `
<details class="scroll-letter" open>
  <summary>
    <span class="seal">✶</span>
    Official Correspondence: The Oracle Qualification Trials
    <span class="chev">▶</span>
  </summary>

  <div class="scroll-content">
    <div style="text-align:center; font-style:italic; color:var(--muted); margin-bottom:1rem;">
      From the Office of the Dean of Arcane Affairs<br>
      Strixhaven University — The Premier Institution of Magical Learning in the World<br>
      <small>Founded by the Five Dragons — Velomachus, Galazeth, Tanazir, Shadrix, and Beledros</small>
    </div>

    <hr style="border:none;border-top:1px dotted var(--border);margin:1rem 0;">

    <p><strong>Winter Term • Year 739 of Archavios</strong></p>
    <p><em>An Invitation to the Learned and the Brave,</em></p>

    <p>In preparation for this century’s selection of the Oracle Apprentice, the University will conduct a series of sanctioned field examinations. Each Trial is designed to assess essential qualities of leadership, wisdom, and magical aptitude expected of one who may one day inherit the Oracle’s mantle. <br><br>

    Participants will represent their chosen college and be evaluated by a panel of distinguished faculty and arcane observers. Though each Trial varies in format, all share a single purpose — to illuminate the heart, mind, and will of every contender.<br>

    <p>Strixhaven is honoured to welcome distinguished students and faculty from magical academies across the planes for this year’s Oracle Trials. Each institution brings its own traditions, theories, and flavour of chaos to the proceedings — ensuring that no two duels, debates, or dissertations are ever the same.</p>

    <div class="table-scroll letter-table">
      <table class="table">
        <thead><tr><th>College</th><th>Field of Study</th><th>Founder Dragon</th></tr></thead>
        <tbody>
          <tr><td><strong>Lorehold</strong></td><td>History & Archaeomancy</td><td>Velomachus Lorehold</td></tr>
          <tr><td><strong>Prismari</strong></td><td>Elemental Arts & Expression</td><td>Galazeth Prismari</td></tr>
          <tr><td><strong>Quandrix</strong></td><td>Numeromancy & Natural Mathematics</td><td>Tanazir Quandrix</td></tr>
          <tr><td><strong>Silverquill</strong></td><td>Eloquence, Rhetoric, & Word Magic</td><td>Shadrix Silverquill</td></tr>
          <tr><td><strong>Witherbloom</strong></td><td>Essence Studies: Life & Death</td><td>Beledros Witherbloom</td></tr>
        </tbody>
      </table>
    </div>

    <p><strong>Student Expectations</strong><br>
      Arrive prepared for adventure, study, and a modest amount of chaos.<br>
      Dice, imagination, and one’s best festive attire recommended.<br>
      Non-finalists may appear as professors, spirits, or helpful onlookers via “Supporter Cards.”<br>
      Cooperation, roleplay, and good humour will be rewarded; detentions will be minimal.
    </p>
    
    <section class="news-board" id="newsBoard">
  <h3>Games & Trials</h3>
  <p class="muted">All scholars will compete in select Trials, contributing their unique philosophies to the greater pursuit of magical mastery. Some seek prestige, others enlightenment — a few, simply the catering.</p>
<p>Dates (Happening in the Mortal World)</p>
<p><strong>3 Preliminary College Quests: December 21–29<br>
Grand Oracle Trial: January 1</strong></p>
<p>(Trials hosted in the mortal realm by Professors Kaela and Tory. Potluck encouraged.)</p>
  
  <details class="news-item" closed>
    <summary>
      <span class="dot" aria-hidden="true"></span>
      <span class="news-title-text">Trial I: The Bog Expedition (Date TBD)</span>
      <span class="chev" aria-hidden="true">▶</span>
    </summary>
    <div class="news-body">
      <ul>
        <li><strong>Theme:</strong> Resilience & Compassion</li>
        <li><strong>Focus:</strong> Problem-solving, teamwork, and moral decisions under pressure.</li>
        <li><strong>Setting:</strong> Witherbloom’s Detention Bog.</li>
        <li><strong>Premise:</strong> Participants are sent to assist Witherbloom faculty in recovering lost alchemical crates.</li>
      </ul>
    </div>
  </details>
  
  <details class="news-item" closed>
    <summary>
      <span class="dot" aria-hidden="true"></span>
      <span class="news-title-text">Trial II: The Masquerade of Mirrors (Date TBD)</span>
      <span class="chev" aria-hidden="true">▶</span>
    </summary>
    <div class="news-body">
      <ul>
        <li><strong>Theme:</strong> Wisdom & Integrity</li>
        <li><strong>Focus:</strong> Deception, charm, and truth-seeking.</li>
        <li><strong>Setting:</strong> The Winter Masquerade Ball, hosted by Silverquill and Prismari.</li>
        <li><strong>Premise:</strong> Contestants attend an extravagant gala where faculty and students vie for influence.</li>
      </ul>
    </div>
  </details>
  
  <details class="news-item" closed>
    <summary>
      <span class="dot" aria-hidden="true"></span>
      <span class="news-title-text">Trial III: The Trial of the Ruins (Date TBD)</span>
      <span class="chev" aria-hidden="true">▶</span>
    </summary>
    <div class="news-body">
      <ul>
        <li><strong>Theme:</strong> Courage & Judgement.</li>
        <li><strong>Focus:</strong> Exploration, strategy, and moral courage.</li>
        <li><strong>Setting:</strong> The Fortress Badlands.</li>
        <li><strong>Premise:</strong> This test appears to be a straightforward recovery mission. Retrieve relics from ancient battlefields.</li>
      </ul>
    </div>
  </details>
  
  <details class="news-item" closed>
    <summary>
      <span class="dot" aria-hidden="true"></span>
      <span class="news-title-text">Finale: The Oracle’s Convergence (January 1, 2026)</span>
      <span class="chev" aria-hidden="true">▶</span>
    </summary>
    <div class="news-body">
      <ul>
        <li><strong>Focus:</strong> Everyone together — chaos, redemption, and a vote for destiny.</li>
        <li><strong>Format:</strong> Hybrid roleplay + short “tournament” style mini-games.</li>
        <li><strong>Structure:</strong> Reunion Scene: All characters (kids & adults) witness the Oracle’s unstable spirit forming.</li>
        <li><strong>Challenges:</strong> 
          <li>Puzzle of Insight (Wisdom)</li>
          <li>Duel of Flames (Power)
          <li>Debate of Hearts (Charisma)
          <li><strong>Audience votes or donates coins/tokens to alter results.</strong></li>
      </ul>
      <p><strong>Final Choice:</strong> Whoever wins or earns the group’s vote becomes the Oracle Apprentice.</p>
    </div>
  </details>
</section>

    <p>Should you accept, please confirm attendance and college preference. Positions are limited, and the Founders favour the punctual.</p>

    <p style="margin-top:1.1rem;">
      <strong>With warm regards and arcane esteem,</strong><br><br>
      <em>Professor Kaela of House Glissandiants</em><br>
      <em>Contact kaelacaron@gmail.com</em><br>
      <em>Department of Druidic Studies</em><br><br>
      <em>Professor Tory of House Wittatude</em><br>
      <em>School of Bardic Applications</em><br><br>
      <strong>Strixhaven University of Magic and Mystery</strong>
    </p>

    <p style="text-align:center; font-style:italic; margin-top:1rem;">“To discover, preserve, and share the boundless wonders of magic.”</p>
  </div>
</details>

<section class="quest-board" id="questBoard">
  <h3>Quest Board</h3>
  <p class="muted">Live adventures pulled from the Oracle Trials database snapshot.</p>
  <div id="questList" class="quest-list" role="list">
    <p class="muted">Loading quests…</p>
  </div>
</section>

<section class="news-board" id="newsBoard">
  <h3>Announcements &amp; Updates</h3>
  <p class="muted">Drop in quick notes for the group. Duplicate the sample dropdown below to add more updates.</p>
  <details class="news-item" open>
    <summary>
      <span class="dot" aria-hidden="true"></span>
      <span class="news-title-text">Sample Update — Replace Me</span>
      <span class="chev" aria-hidden="true">▶</span>
    </summary>
    <div class="news-body">
      <p>Share schedule changes, supply lists, or links here. Copy this entire <code>&lt;details class="news-item"&gt;</code> block to post another note.</p>
      <ul>
        <li><strong>When:</strong> Example date and time</li>
        <li><strong>Where:</strong> Library of the Biblioplex</li>
        <li><strong>Bring:</strong> Dice, pencils, favourite snack</li>
      </ul>
    </div>
  </details>
</section>

<section class="comment-board" id="commentBoard">
  <h3>Comments &amp; Notes</h3>
  <p class="muted">Jot reminders or questions for the group. Comments sync through the Oracle Archives so everyone stays in the loop.</p>
  <form id="commentForm" class="comment-form">
    <div class="comment-form-grid">
      <div class="form-field">
        <label for="commentPlayer">Player name (optional)</label>
        <input id="commentPlayer" name="commentPlayer" autocomplete="off" placeholder="e.g., Tamsin Rowe" />
      </div>
      <div class="form-field">
        <label for="commentCharacter">Character name (optional)</label>
        <input id="commentCharacter" name="commentCharacter" autocomplete="off" placeholder="e.g., Althea the Clever" />
      </div>
      <div class="form-field">
        <label for="commentSession">Session ID (optional)</label>
        <input id="commentSession" name="commentSession" autocomplete="off" placeholder="e.g., s3 or finale" />
      </div>
    </div>
    <label for="commentText">Add a comment</label>
    <textarea id="commentText" name="commentText" placeholder="Thanks for the invite! I'll bring cocoa." aria-label="Comment text"></textarea>
    <div class="comment-actions">
      <button type="button" id="refreshComments" class="secondary">Refresh</button>
      <button type="submit" class="primary">Post Comment</button>
    </div>
    <p id="commentStatus" class="comment-status" aria-live="polite" role="status" hidden></p>
  </form>
  <div id="commentList" class="comment-list" aria-live="polite"></div>
</section>

  `;
  setupCommentBoard(p);
  hydrateQuestBoard(p);
  return p;
}



function panelSessions(){
  const p = document.createElement('div');
  p.className = 'panel';
  p.innerHTML = `
    <h2>Availability</h2>
    <div class="card avail-card">
      <form id="roster_quick_form" class="roster-form roster-quick-add" autocomplete="off">
        <div class="roster-form-grid">
          <div class="form-field">
            <label for="roster_quick_name">Name</label>
            <input id="roster_quick_name" name="name" placeholder="e.g., Tamsin Rowe" />
          </div>
          <div class="form-field">
            <label for="roster_quick_status">Status</label>
            <input id="roster_quick_status" name="status" placeholder="Yes / Maybe / No" />
          </div>
          <div class="form-field form-field-notes">
            <label for="roster_quick_notes">Notes</label>
            <textarea id="roster_quick_notes" name="notes" rows="2" placeholder="Add reminders or context"></textarea>
          </div>
        </div>
        <div class="form-actions">
          <button type="submit" class="primary">Add Person</button>
        </div>
      </form>
      <div class="form-message" id="roster_feedback" role="status" aria-live="polite" hidden></div>
      <div class="table-scroll">
        <table class="table avail" id="avail_table">
          <thead>
            <tr>
              <th>Name</th>
              ${AVAIL_DATES.map(d => `<th title="${d}">${labelDate(d)}</th>`).join('')}
            </tr>
          </thead>
          <tbody id="roster_tbody"></tbody>
        </table>
      </div>
      <div class="muted" style="margin-top:6px">
        Tick when someone is available. Changes sync to the shared datastore automatically (with an offline cache on this device).
      </div>
    </div>
    <div class="card roster-removed-card" id="removed_roster_card" hidden>
      <h3>Hidden roster</h3>
      <p class="muted" id="removed_roster_hint">Restore entries hidden from the availability table.</p>
      <ul id="removed_roster_list" class="removed-roster-list"></ul>
    </div>
    <div class="controls">
      <div class="left">
        <button id="add_person">+ Add Person</button>
        <button id="back_sessions">← Back</button>
      </div>
      <div class="right">
        <button id="csv_export">Export Availability CSV</button>
        <button id="next_sessions" class="primary">Next →</button>
      </div>
    </div>
  `;

  const rbody = p.querySelector('#roster_tbody');
  const tableScroll = p.querySelector('.table-scroll');
  const quickForm = p.querySelector('#roster_quick_form');
  const quickNameInput = p.querySelector('#roster_quick_name');
  const quickStatusInput = p.querySelector('#roster_quick_status');
  const quickNotesInput = p.querySelector('#roster_quick_notes');
  const rosterFeedback = p.querySelector('#roster_feedback');
  const removedCard = p.querySelector('#removed_roster_card');
  const removedList = p.querySelector('#removed_roster_list');

  let inlineEditorState = { key: null, mode: null };
  let inlineTriggerFocus = null;
  let pendingFocus = null;

  function showRosterFeedback(text='', variant='info'){
    if(!rosterFeedback) return;
    rosterFeedback.textContent = text;
    rosterFeedback.classList.remove('error','success');
    if(!text){
      rosterFeedback.hidden = true;
      return;
    }
    rosterFeedback.hidden = false;
    if(variant === 'error') rosterFeedback.classList.add('error');
    if(variant === 'success') rosterFeedback.classList.add('success');
  }

  function describeTriggerButton(btn){
    if(!btn) return null;
    if(btn.hasAttribute('data-edit')){
      return { type: 'edit', key: btn.getAttribute('data-edit') };
    }
    if(btn.hasAttribute('data-remove')){
      return { type: 'remove', key: btn.getAttribute('data-remove') };
    }
    return null;
  }

  function findTriggerButton(info){
    if(!info) return null;
    if(info.type === 'edit'){
      return Array.from(rbody.querySelectorAll('button[data-edit]')).find(btn => btn.getAttribute('data-edit') === info.key) || null;
    }
    if(info.type === 'remove'){
      return Array.from(rbody.querySelectorAll('button[data-remove]')).find(btn => btn.getAttribute('data-remove') === info.key) || null;
    }
    return null;
  }

  function restoreTriggerFocus(){
    if(!inlineTriggerFocus) return;
    const btn = findTriggerButton(inlineTriggerFocus);
    if(btn){
      btn.focus();
    } else if(quickNameInput){
      quickNameInput.focus();
    }
    inlineTriggerFocus = null;
  }

  function setInlineMessage(form, text='', variant='info'){
    const msg = form ? form.querySelector('[data-inline-message]') : null;
    if(!msg) return;
    msg.textContent = text;
    msg.classList.remove('error','success');
    if(!text){
      msg.hidden = true;
      return;
    }
    msg.hidden = false;
    if(variant === 'error') msg.classList.add('error');
    if(variant === 'success') msg.classList.add('success');
  }

  function renderInlineEditorRow(entry){
    if(inlineEditorState.key !== entry.key || !inlineEditorState.mode){
      return '';
    }
    const colSpan = AVAIL_DATES.length + 1;
    if(inlineEditorState.mode === 'edit'){
      const statusValue = entry.status || '';
      const notesValue = entry.notes || '';
      return `<tr class="inline-editor" data-editor-row="${entry.key}"><td colspan="${colSpan}"><form class="roster-inline-editor" data-inline-form data-mode="edit" data-key="${entry.key}"><div class="roster-form-grid"><div class="form-field"><label>Status</label><input name="status" value="${escapeAttr(statusValue)}" data-editor-input="status" placeholder="Yes / Maybe / No" /></div><div class="form-field form-field-notes"><label>Notes</label><textarea name="notes" rows="2" data-editor-input="notes" placeholder="Add reminders or context">${escapeHTML(notesValue)}</textarea></div></div><div class="form-message" data-inline-message hidden></div><div class="form-actions"><button type="button" class="link-button" data-cancel>Cancel</button><button type="submit" class="primary">Save</button></div></form></td></tr>`;
    }
    if(inlineEditorState.mode === 'remove'){
      const actionLabel = entry.custom ? 'Remove' : 'Hide';
      const explainer = entry.custom ? 'Remove this custom entry from the roster? You can re-add it later.' : 'Hide this roster entry? You can restore hidden players below.';
      return `<tr class="inline-editor" data-editor-row="${entry.key}"><td colspan="${colSpan}"><form class="roster-inline-editor" data-inline-form data-mode="remove" data-key="${entry.key}"><p><strong>${escapeHTML(entry.name)}</strong> — ${escapeHTML(explainer)}</p><div class="form-message" data-inline-message hidden></div><div class="form-actions"><button type="button" class="link-button" data-cancel>Cancel</button><button type="submit" class="danger" data-confirm>${actionLabel}</button></div></form></td></tr>`;
    }
    return '';
  }

  function renderRemovedRoster(){
    if(!removedCard || !removedList) return;
    const hiddenEntries = getHiddenRosterEntries();
    if(!hiddenEntries.length){
      removedList.innerHTML = '';
      removedCard.hidden = true;
      return;
    }
    removedCard.hidden = false;
    removedList.innerHTML = hiddenEntries.map((entry)=>{
      const metaParts = [];
      if(entry.status){
        metaParts.push(`Status: ${escapeHTML(entry.status)}`);
      }
      if(entry.notes){
        metaParts.push(`Notes: ${escapeHTML(entry.notes)}`);
      }
      const meta = metaParts.length ? `<div class="removed-meta muted">${metaParts.join(' • ')}</div>` : '';
      return `<li class="removed-roster-item"><div class="removed-entry"><strong>${escapeHTML(entry.name)}</strong>${meta}</div><button type="button" class="link-button" data-restore="${entry.key}" data-name="${escapeAttr(entry.name)}">Restore</button></li>`;
    }).join('');
  }

  function renderAvailabilityTable(opts={}){
    const avail = AvailabilityStore.read();
    const roster = getRosterList();
    const preserveScroll = typeof opts.scrollLeft === 'number' ? opts.scrollLeft : tableScroll.scrollLeft;
    if(!roster.length){
      rbody.innerHTML = `<tr><td colspan="${AVAIL_DATES.length + 1}" class="muted" style="text-align:center">Add people with the <em>Add Person</em> button to start tracking schedules.</td></tr>`;
      tableScroll.scrollLeft = preserveScroll;
      renderRemovedRoster();
      return;
    }
    const rows = roster.map((entry)=>{
      const rowAvail = avail[entry.key] || {};
      const metaBits = [];
      if(entry.status){
        const statusClass = entry.status ? `status-${entry.status.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/^-+|-+$/g,'') || 'default'}` : 'status-default';
        metaBits.push(`<span class="status-pill ${statusClass}">${escapeHTML(entry.status)}</span>`);
      }
      if(entry.notes){
        metaBits.push(`<span class="note-pill">${escapeHTML(entry.notes)}</span>`);
      }
      const metaLine = metaBits.length ? `<div class="name-meta">${metaBits.join(' ')}</div>` : '';
      const actions = `<div class="name-actions">
        <button type="button" class="link-button" data-edit="${entry.key}" data-name="${escapeAttr(entry.name)}">Edit</button>
        <button type="button" class="link-button danger" data-remove="${entry.key}" data-name="${escapeAttr(entry.name)}" data-remove-type="${entry.custom ? 'custom' : 'base'}">Remove</button>
      </div>`;
      const cells = AVAIL_DATES.map((d)=>{
        const checked = rowAvail[d] ? ' checked' : '';
        return `<td><input data-key="${entry.key}" data-name="${escapeAttr(entry.name)}" data-date="${d}" type="checkbox"${checked}></td>`;
      }).join('');
      const mainRow = `<tr><td class="avail-name"><strong>${escapeHTML(entry.name)}</strong>${metaLine}${actions}</td>${cells}</tr>`;
      const inlineRow = renderInlineEditorRow(entry);
      return inlineRow ? `${mainRow}${inlineRow}` : mainRow;
    }).join('');
    rbody.innerHTML = rows;
    tableScroll.scrollLeft = preserveScroll;
    if(opts.focus && opts.focus.date && (opts.focus.key || opts.focus.name)){
      const targetFocus = opts.focus;
      requestAnimationFrame(()=>{
        const focusInput = Array.from(rbody.querySelectorAll('input[data-key][data-date]')).find((el)=>{
          if(targetFocus.key){
            return el.getAttribute('data-key') === targetFocus.key && el.getAttribute('data-date') === targetFocus.date;
          }
          return el.getAttribute('data-name') === targetFocus.name && el.getAttribute('data-date') === targetFocus.date;
        });
        if(focusInput){
          focusInput.focus({ preventScroll:true });
        }
      });
    }
    if(typeof pendingFocus === 'function'){
      requestAnimationFrame(()=>{
        const el = pendingFocus();
        if(el){
          el.focus({ preventScroll:true });
        }
        pendingFocus = null;
      });
    }
    if(opts.restoreFocus){
      requestAnimationFrame(()=>{
        restoreTriggerFocus();
      });
    }
    renderRemovedRoster();
  }

  renderAvailabilityTable();

  // Save on change
  rbody.addEventListener('change', async (e) => {
    const cb = e.target.closest('input[type="checkbox"][data-key][data-name]');
    if(!cb) return;
    const key = cb.getAttribute('data-key');
    const name = cb.getAttribute('data-name');
    const date = cb.getAttribute('data-date');
    const newValue = cb.checked;
    try{
      await Backend.setAvailability({ name, playerName: name, playerKey: key, date, available: newValue });
      renderAvailabilityTable({ focus:{ key, name, date }, scrollLeft: tableScroll.scrollLeft });
    }catch(err){
      cb.checked = !newValue;
      alert(`Failed to update availability: ${err && err.message ? err.message : 'Request failed.'}`);
    }
  });

  rbody.addEventListener('click', (event) => {
    const editBtn = event.target.closest('button[data-edit]');
    if(editBtn){
      const key = editBtn.getAttribute('data-edit');
      const roster = getRosterList();
      const entry = roster.find(r=>r.key === key);
      if(!entry) return;
      if(inlineEditorState.key === key && inlineEditorState.mode === 'edit'){
        inlineEditorState = { key: null, mode: null };
        renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft, restoreFocus: true });
        return;
      }
      inlineTriggerFocus = describeTriggerButton(editBtn);
      inlineEditorState = { key, mode: 'edit' };
      pendingFocus = () => {
        const form = Array.from(rbody.querySelectorAll('form[data-inline-form]')).find(f => f.dataset.mode === 'edit' && f.dataset.key === key);
        if(!form) return null;
        return form.querySelector('[data-editor-input="status"]') || form.querySelector('[data-editor-input="notes"]');
      };
      showRosterFeedback();
      renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft });
      return;
    }
    const removeBtn = event.target.closest('button[data-remove]');
    if(removeBtn){
      const key = removeBtn.getAttribute('data-remove');
      const roster = getRosterList();
      const entry = roster.find(r=>r.key === key);
      if(!entry) return;
      if(inlineEditorState.key === key && inlineEditorState.mode === 'remove'){
        inlineEditorState = { key: null, mode: null };
        renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft, restoreFocus: true });
        return;
      }
      inlineTriggerFocus = describeTriggerButton(removeBtn);
      inlineEditorState = { key, mode: 'remove' };
      pendingFocus = () => {
        const form = Array.from(rbody.querySelectorAll('form[data-inline-form]')).find(f => f.dataset.mode === 'remove' && f.dataset.key === key);
        if(!form) return null;
        return form.querySelector('[data-confirm]') || form.querySelector('button[type="submit"]');
      };
      showRosterFeedback();
      renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft });
      return;
    }
    const cancelBtn = event.target.closest('button[data-cancel]');
    if(cancelBtn){
      const form = cancelBtn.closest('form[data-inline-form]');
      if(form){
        inlineEditorState = { key: null, mode: null };
        renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft, restoreFocus: true });
      }
    }
  });

  rbody.addEventListener('submit', async (event) => {
    const form = event.target.closest('form[data-inline-form]');
    if(!form) return;
    event.preventDefault();
    const mode = form.dataset.mode;
    const key = form.dataset.key;
    const roster = getRosterList({ includeHidden: true });
    const entry = roster.find(r=>r.key === key);
    if(!entry){
      setInlineMessage(form, 'Roster entry not found.', 'error');
      return;
    }
    setInlineMessage(form);
    try{
      if(mode === 'edit'){
        const statusValue = form.elements.status ? form.elements.status.value : '';
        const notesValue = form.elements.notes ? form.elements.notes.value : '';
        await updateRosterDetails(key, entry, statusValue, notesValue);
        inlineEditorState = { key: null, mode: null };
        renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft, restoreFocus: true });
        showRosterFeedback(`Saved updates for ${entry.name}.`, 'success');
      } else if(mode === 'remove'){
        await setRosterHidden(entry, true);
        inlineEditorState = { key: null, mode: null };
        renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft, restoreFocus: true });
        showRosterFeedback(`${entry.name} is now hidden. Restore hidden entries below.`, 'success');
      }
    }catch(err){
      setInlineMessage(form, err && err.message ? err.message : 'Request failed. Please try again.', 'error');
    }
  });

  if(removedList){
    removedList.addEventListener('click', async (event)=>{
      const restoreBtn = event.target.closest('button[data-restore]');
      if(!restoreBtn) return;
      const key = restoreBtn.getAttribute('data-restore');
      try{
        const roster = getRosterList({ includeHidden: true });
        const entry = roster.find(r=>r.key === key);
        if(entry){
          await setRosterHidden(entry, false);
          renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft });
          showRosterFeedback(`${entry.name} restored to the roster.`, 'success');
        }
      }catch(err){
        showRosterFeedback(err && err.message ? err.message : 'Failed to restore entry.', 'error');
      }
    });
  }

  const addBtn = p.querySelector('#add_person');
  if(addBtn){
    addBtn.onclick = () => {
      inlineEditorState = { key: null, mode: null };
      showRosterFeedback();
      if(quickNameInput){
        quickNameInput.focus();
      }
    };
  }

  if(quickForm){
    quickForm.addEventListener('submit', async (event)=>{
      event.preventDefault();
      showRosterFeedback();
      const rawName = quickNameInput ? quickNameInput.value : '';
      const cleanName = sanitizeName(rawName);
      const cleanStatus = sanitizeOptional(quickStatusInput ? quickStatusInput.value : '');
      const cleanNotes = sanitizeOptional(quickNotesInput ? quickNotesInput.value : '');
      if(!cleanName){
        showRosterFeedback('Name is required.', 'error');
        if(quickNameInput){
          quickNameInput.focus();
        }
        return;
      }
      const key = rosterKey(cleanName);
      if(rosterHasKey(key)){
        showRosterFeedback(`${cleanName} is already on the roster.`, 'error');
        if(quickNameInput){
          quickNameInput.focus();
          if(typeof quickNameInput.select === 'function') quickNameInput.select();
        }
        return;
      }
      try{
        const result = await addRosterExtra(cleanName, cleanStatus, cleanNotes);
        if(!result.ok){
          showRosterFeedback(result.msg || 'Failed to add roster entry.', 'error');
          return;
        }
        if(quickNameInput) quickNameInput.value = '';
        if(quickStatusInput) quickStatusInput.value = '';
        if(quickNotesInput) quickNotesInput.value = '';
        inlineEditorState = { key: null, mode: null };
        renderAvailabilityTable({ scrollLeft: tableScroll.scrollLeft });
        showRosterFeedback(`${cleanName} added to the roster.`, 'success');
        if(quickNameInput){
          quickNameInput.focus();
        }
      }catch(err){
        showRosterFeedback(err && err.message ? err.message : 'Request failed. Please try again.', 'error');
      }
    });
  }

  p.querySelector('#csv_export').onclick = downloadAvailabilityCSV;
  p.querySelector('#back_sessions').onclick = () => { activateStep(STEPS.findIndex(s => s.key === 'intro')); };
  p.querySelector('#next_sessions').onclick = () => { activateStep(STEPS.findIndex(s => s.key === 'core')); };

  return p;
}


  function panelCore(){
    const p = document.createElement('div'); p.className='panel';
    p.innerHTML = `
      <h2>Core 5e Setup</h2>
      <div class="callout" aria-label="Character creation instructions">
        <strong>Quick build checklist:</strong>
        <ul>
          <li>Enter your <strong>player name</strong> and <strong>character name</strong>.</li>
          <li>Pick a race, class, background, level, and ability score method.</li>
          <li>Select starting equipment — class kit or 50 gp.</li>
          <li>Need a refresher? Try the <a href="https://dnd.wizards.com/resources/character-sheets" target="_blank" rel="noreferrer">official D&D 5e character sheets</a>.</li>
        </ul>
      </div>
      <div class="grid cols-2">
        <div><label>Player Name</label><input id="core_player" placeholder="e.g., Kaela" /></div>
        <div><label>Character Name</label><input id="core_name" placeholder="e.g., Aria Winterborn" /></div>
        <div><label>Level</label><select id="core_level"></select></div>
        <div><label>Race</label><input id="core_race" placeholder="Any 5e race" /></div>
        <div><label>Class</label><input id="core_class" placeholder="Any 5e class" /></div>
        <div><label>Background</label><input id="core_background" placeholder="PHB/Custom" /></div>
        <div>
          <label>Ability Scores</label>
          <div class="row">
            <select id="ability_method">
              <option value="standard">Standard Array (15,14,13,12,10,8)</option>
              <option value="manual">Manual Entry</option>
            </select>
            <select id="equipment">
              <option value="class">Class Starting Equipment</option>
              <option value="50gp">50 gp</option>
            </select>
          </div>
        </div>
      </div>
      <div id="ability_box" class="two" style="margin-top:10px"></div>
      <div class="controls">
        <div class="left"></div>
        <div class="right"><button class="primary" id="next_core">Next →</button></div>
      </div>
    `;

    const levelSel = p.querySelector('#core_level');
    DATA.levels.forEach(l=>{ const o=document.createElement('option'); o.value=l; o.textContent=l; levelSel.appendChild(o); });

    const box = p.querySelector('#ability_box');
    function drawAbilityInputs(){
      box.innerHTML='';
      const m = p.querySelector('#ability_method').value;
      const abilities = ['STR','DEX','CON','INT','WIS','CHA'];
      if(m==='standard'){
        const arr = DATA.abilityArrays.standard.slice();
        abilities.forEach((ab)=>{
          const d=document.createElement('div'); d.className='card';
          d.innerHTML=`<label>${ab}</label><select data-ab="${ab}">${arr.map(v=>`<option value="${v}">${v}</option>`).join('')}</select>`;
          box.appendChild(d);
        });
      } else {
        abilities.forEach(ab=>{
          const d=document.createElement('div'); d.className='card';
          d.innerHTML=`<label>${ab}</label><input type="number" min="3" max="18" value="10" data-ab="${ab}" />`;
          box.appendChild(d);
        });
      }
    }
    p.querySelector('#ability_method').addEventListener('change', drawAbilityInputs);
    drawAbilityInputs();

    const s = State.data.core;
    p.querySelector('#core_player').value = s.playerName || '';
    p.querySelector('#core_name').value = s.name;
    p.querySelector('#core_race').value = s.race;
    p.querySelector('#core_class').value = s.class;
    p.querySelector('#core_background').value = s.background;
    p.querySelector('#core_level').value = s.level;
    p.querySelector('#ability_method').value = s.abilityMethod;
    p.querySelector('#equipment').value = s.equipment;
    drawAbilityInputs();

    p.querySelector('#next_core').onclick = ()=>{
      const abilities = ['STR','DEX','CON','INT','WIS','CHA'];
      const abObj = {};
      abilities.forEach(ab=>{
        const el = box.querySelector(`[data-ab="${ab}"]`);
        abObj[ab] = parseInt(el.value,10);
      });
      State.data.core = {
        playerName: p.querySelector('#core_player').value.trim(),
        name: p.querySelector('#core_name').value.trim(),
        race: p.querySelector('#core_race').value.trim(),
        class: p.querySelector('#core_class').value.trim(),
        background: p.querySelector('#core_background').value.trim(),
        level: parseInt(p.querySelector('#core_level').value,10),
        abilityMethod: p.querySelector('#ability_method').value,
        abilities: abObj,
        equipment: p.querySelector('#equipment').value
      };
      activateStep(STEPS.findIndex(s=>s.key==='university'));
    };
    return p;
  }

  function panelUniversity(){
    const p=document.createElement('div'); p.className='panel';
    p.innerHTML=`
      <h2>University & Feat</h2>
      <div class="grid cols-2">
        <div>
          <label>Choose University</label>
          <select id="uni"></select>
        </div>
        <div>
          <label>Strixhaven Initiate — Spellcasting Ability</label>
          <select id="spell_ability"><option>INT</option><option>WIS</option><option>CHA</option></select>
        </div>
      </div>
      <div id="uni_info" class="card" style="margin-top:10px"></div>
      <div class="controls">
        <div class="left"><button id="back_u">← Back</button></div>
        <div class="right"><button class="primary" id="next_u">Next →</button></div>
      </div>
    `;
    const sel=p.querySelector('#uni');
    sel.innerHTML = `<option value="">— Select —</option>`+DATA.universities.map(u=>`<option value="${u.key}">${u.name}</option>`).join('');
    function drawInfo(){
      const key = sel.value; const out=p.querySelector('#uni_info');
      if(!key){ out.innerHTML='<span class="muted">Select a university to view theme & bonus spells.</span>'; return; }
      const u = DATA.universities.find(x=>x.key===key);
      const spellRows = Object.entries(u.spells).map(([lvl,list])=>`<tr><td>${lvl}</td><td>${list.join(', ')}</td></tr>`).join('');
      out.innerHTML = `
        <div class="two">
          <div>
            <div class="kicker">Theme</div><div>${u.theme}</div>
            <div class="kicker" style="margin-top:6px">Focus</div><div>${u.focus}</div>
            <div class="kicker" style="margin-top:6px">Colours</div><div>${u.colours}</div>
            <div class="kicker" style="margin-top:6px">Playstyle</div><div>${u.playstyle}</div>
          </div>
          <div>
            <div class="kicker">Bonus Spells</div>
            <table class="table"><thead><tr><th>Level</th><th>Spells</th></tr></thead><tbody>${spellRows}</tbody></table>
          </div>
        </div>
        <div class="callout" style="margin-top:8px"><strong>Feat:</strong> ${DATA.feats.strixhavenInitiate.name} — ${DATA.feats.strixhavenInitiate.text}</div>
      `;
    }
    sel.addEventListener('change', drawInfo);
    sel.value = State.data.university.key || '';
    p.querySelector('#spell_ability').value = State.data.university.spellAbility || 'INT';
    drawInfo();
    p.querySelector('#back_u').onclick=()=>{activateStep(STEPS.findIndex(s=>s.key==='core'));};
    p.querySelector('#next_u').onclick=()=>{
      State.data.university={ key: sel.value, spellAbility: p.querySelector('#spell_ability').value };
      if(!State.data.university.key){ alert('Pick a university to continue.'); return; }
      if(!State.data.feats.find(f=>f.name==='Strixhaven Initiate')){
        State.data.feats.push({name:'Strixhaven Initiate', ability: State.data.university.spellAbility });
      } else {
        State.data.feats = State.data.feats.map(f=> f.name==='Strixhaven Initiate'? {...f, ability: State.data.university.spellAbility }: f);
      }
      activateStep(STEPS.findIndex(s=>s.key==='extras'));
    };
    return p;
  }

  function panelExtras(){
    const p=document.createElement('div'); p.className='panel';
    p.innerHTML=`
      <h2>Job & Extracurriculars</h2>
      <div class="grid cols-2">
        <div>
          <label>Job (optional, 5 gp/week)</label>
          <select id="job"><option value="">— None —</option>${DATA.jobs.map(j=>`<option value="${j.key}">${j.name}</option>`).join('')}</select>
        </div>
        <div>
          <label>Extracurriculars (pick up to 2; 1 if you also take a job)</label>
          <div id="clublist" class="grid cols-2" style="max-height:240px;overflow:auto"></div>
        </div>
      </div>
      <div id="bonus_readout" class="callout" style="margin-top:10px"></div>
      <div class="controls">
        <div class="left"><button id="back_e">← Back</button></div>
        <div class="right"><button class="primary" id="next_e">Next →</button></div>
      </div>
    `;
    const clubWrap = p.querySelector('#clublist');
    function drawClubs(){
      clubWrap.innerHTML='';
      DATA.extracurriculars.forEach(c=>{
        const id=`club_${c.key}`;
        const d=document.createElement('label'); d.className='card'; d.style.cursor='pointer';
        d.innerHTML=`<div class="flex"><input type="checkbox" id="${id}" data-key="${c.key}" /> <div><strong>${c.name}</strong><div class="muted">Student Die (d4): ${c.skills.join(' / ')}</div></div></div>`;
        clubWrap.appendChild(d);
      });
    }
    drawClubs();

    const jobSel = p.querySelector('#job');
    jobSel.value = State.data.extras.job || '';
    (State.data.extras.clubs||[]).forEach(k=>{ const el = clubWrap.querySelector(`[data-key="${k}"]`); if(el) el.checked=true; });

    function readExtras(){
      const jobKey = jobSel.value || null;
      const pickedClubs = [...clubWrap.querySelectorAll('input[type="checkbox"]:checked')].map(x=>x.dataset.key);
      const maxClubs = jobKey?1:2;
      if(pickedClubs.length>maxClubs){
        const last = pickedClubs.pop();
        clubWrap.querySelector(`[data-key="${last}"]`).checked=false;
      }
      const job = DATA.jobs.find(j=>j.key===jobKey);
      const clubs = DATA.extracurriculars.filter(c=>pickedClubs.includes(c.key));
      const parts=[];
      if(job) parts.push(`<span class="tag">Job: ${job.name} — d4: ${job.skills.join(' / ')}</span>`);
      clubs.forEach(c=>parts.push(`<span class="tag">Club: ${c.name} — d4: ${c.skills.join(' / ')}</span>`));
      p.querySelector('#bonus_readout').innerHTML = parts.length? parts.join(' '): '<span class="muted">Pick a job and/or clubs to see Student Dice bonuses.</span>';
      return { job: jobKey, clubs: pickedClubs };
    }

    jobSel.addEventListener('change', readExtras);
    clubWrap.addEventListener('change', readExtras);
    readExtras();

    p.querySelector('#back_e').onclick=()=>{activateStep(STEPS.findIndex(s=>s.key==='university'));};
    p.querySelector('#next_e').onclick=()=>{
      const {job, clubs} = readExtras();
      State.data.extras.job = job;
      State.data.extras.clubs = clubs;
      activateStep(STEPS.findIndex(s=>s.key==='personality'));
    };
    return p;
  }

  function panelPersonality(){
    const p=document.createElement('div'); p.className='panel';
    p.innerHTML=`
      <h2>Personality & Prompt</h2>
      <div class="grid cols-2">
        <div><label>Traits (1–2)</label><textarea id="traits" rows="3" placeholder="e.g., Curious, dry humour"></textarea></div>
        <div><label>Ideal</label><textarea id="ideal" rows="3" placeholder="e.g., Knowledge must be shared."></textarea></div>
        <div><label>Bond / Friend / Rival</label><textarea id="bond" rows="3" placeholder="Name someone you’re tied to (or opposed to)"></textarea></div>
        <div><label>Goal</label><textarea id="goal" rows="3" placeholder="What do you want from the Oracle Trials?"></textarea></div>
      </div>
      <div class="card" style="margin-top:10px">
        <div class="kicker">Quick-Start Character Prompt</div>
        <div id="prompt_box" class="flex" style="margin-top:6px"></div>
      </div>
      <div class="controls">
        <div class="left"><button id="back_p">← Back</button></div>
        <div class="right"><button class="primary" id="next_p">Next →</button></div>
      </div>
    `;
    const quickPrompts = [
      {u:'Lorehold', text:'A cheerful necro-historian who argues with ghosts about footnotes.'},
      {u:'Prismari', text:'A kinetic dancer who keeps leaving frost footprints after cantrips.'},
      {u:'Quandrix', text:'A fractal botanist who names houseplants after famous equations.'},
      {u:'Silverquill', text:'A sunny orator who spotlights corruption with literal light.'},
      {u:'Witherbloom', text:'A swamp witch medic who collects bones “for research.”'}
    ];
    const box=p.querySelector('#prompt_box');
    quickPrompts.forEach(q=>{
      const b=document.createElement('button'); b.className='pill'; b.type='button';
      b.innerHTML = `<span>${q.u}</span><span>•</span><span>${q.text}</span>`;
      b.onclick=()=>{ State.data.personality.prompt = q.text; Array.from(box.children).forEach(x=>x.classList.remove('success')); b.classList.add('success'); };
      box.appendChild(b);
      if(State.data.personality.prompt===q.text) b.classList.add('success');
    });

    p.querySelector('#traits').value = State.data.personality.traits||'';
    p.querySelector('#ideal').value = State.data.personality.ideal||'';
    p.querySelector('#bond').value = State.data.personality.bond||'';
    p.querySelector('#goal').value = State.data.personality.goal||'';

    p.querySelector('#back_p').onclick=()=>{activateStep(STEPS.findIndex(s=>s.key==='extras'));};
    p.querySelector('#next_p').onclick=()=>{
      State.data.personality={
        traits: p.querySelector('#traits').value.trim(),
        ideal: p.querySelector('#ideal').value.trim(),
        bond: p.querySelector('#bond').value.trim(),
        goal: p.querySelector('#goal').value.trim(),
        prompt: State.data.personality.prompt||''
      };
      activateStep(STEPS.findIndex(s=>s.key==='summary'));
    };
    return p;
  }
    function panelJoin(){
  const p=document.createElement('div'); p.className='panel';
  p.innerHTML = `
    <h2>Join a Session</h2>
    <div class="card">
      <p>Pick a table for your finished character. You’ll need a <strong>Name</strong>, <strong>Class</strong>, <strong>Level</strong>, and a chosen <strong>University</strong>.</p>
    </div>
    <div id="join_list" class="grid"></div>
    <div class="controls">
      <div class="left"><button id="back_join">← Back</button></div>
      <div class="right"><button class="primary" id="to_summary">Next →</button></div>
    </div>
  `;

  const wrap = p.querySelector('#join_list');
  renderSessionCards(wrap, {readOnly:false}); // shows real “Add my character” button

  // click handlers for join + ics
  wrap.addEventListener('click', (ev)=>{
    const addBtn = ev.target.closest('button.primary[data-id]');
    if(addBtn){
      const id = addBtn.getAttribute('data-id');
      const s = (State.sessions||[]).find(x=>x.id===id);
      const name = (State.data.core.name||'').trim();
      if(!name){ alert('Give your character a name (Core 5e).'); return; }
      if (ELIGIBILITY.hardNo.includes(name)) { alert(`${name} is marked as not playing.`); return; }
      if ((ELIGIBILITY.blockedDates[name]||[]).includes(s.date)) { alert(`${name} isn't available for ${s.date}.`); return; }
      const players = Array.isArray(s.players) ? s.players : [];
      if(players.some(player => sanitizeName(player && player.character) === sanitizeName(name))){
        alert('This character is already in that session.');
        return;
      }
      if(players.some(player => rosterKey(player && player.key) === CURRENT_PLAYER_KEY)){
        alert('Your access code already has a seat in this session.');
        return;
      }
      if(players.length>=s.capacity){ alert('That session is full.'); return; }
      // enforce unique university
      const uniName = (DATA.universities.find(u=>u.key===State.data.university.key)?.name)||'';
      const builds = getBuildCards();
      if(uniName){
        for(const player of players){
          const b = player && player.key ? builds[player.key] : null;
          if(b && b.university === uniName){
            alert(`Another ${uniName} student is already in this session. Choose a different session or college.`);
            return;
          }
        }
      }
      const klass = State.data.core.class || '';
      const rosterEntry = PlayerIdentity.getRosterEntry();
      Backend.joinSession(id, {
        name,
        characterName: name,
        playerKey: CURRENT_PLAYER_KEY,
        playerName: rosterEntry?.name,
        build:{ class: klass, university: uniName }
      })
        .then(()=>{
          renderSessionCards(wrap, {readOnly:false});
          alert(`Added ${name} to ${s.title}.`);
        })
        .catch((err)=>{
          alert(`Unable to join ${s.title}: ${err && err.message ? err.message : 'Request failed.'}`);
        });
      return;
    }
    const icsBtn = ev.target.closest('button[data-ics]');
    if(icsBtn){
      const id = icsBtn.getAttribute('data-ics');
      const s = State.sessions.find(x=>x.id===id);
      downloadICS(s);
    }
  });

  p.querySelector('#back_join').onclick = ()=>{ activateStep(STEPS.findIndex(s=>s.key==='personality')); };
  p.querySelector('#to_summary').onclick= ()=>{ activateStep(STEPS.findIndex(s=>s.key==='summary')); };
  return p;
}


  function panelSummary(){
    const p=document.createElement('div'); p.className='panel';
    const s=State.data;
    const uni = DATA.universities.find(u=>u.key===s.university.key);
    const abilityList = Object.entries(s.core.abilities||{}).map(([k,v])=>`<span class="tag">${k}: ${v}</span>`).join(' ');
    const clubs = (s.extras.clubs||[]).map(k=> DATA.extracurriculars.find(c=>c.key===k)?.name).filter(Boolean);
    const jobName = DATA.jobs.find(j=>j.key===s.extras.job)?.name || '—';

    p.innerHTML = `
      <h2>Summary</h2>
      <div class="grid cols-2">
        <div class="card">
          <div class="kicker">Character</div>
          <div><strong>${s.core.name||'Unnamed'}</strong></div>
          <div class="muted">Player: ${s.core.playerName || '—'}</div>
          <div class="muted">${s.core.race||'Race?'} • ${s.core.class||'Class?'} • Level ${s.core.level||3}</div>
          <div style="margin-top:8px">${abilityList}</div>
          <div style="margin-top:8px" class="muted">Background: ${s.core.background||'—'} • Equipment: ${s.core.equipment==='50gp'?'50 gp':'Class kit'}</div>
        </div>
        <div class="card">
          <div class="kicker">University & Feat</div>
          <div><strong>${uni?uni.name:'—'}</strong> <span class="muted">(${uni?uni.colours:'—'})</span></div>
          <div class="muted">Spellcasting Ability for Initiate: ${s.university.spellAbility||'INT'}</div>
        </div>
        <div class="card">
          <div class="kicker">Job & Clubs</div>
          <div>Job: <strong>${jobName}</strong></div>
          <div>Clubs: ${clubs.length? clubs.join(', '): '—'}</div>
        </div>
        <div class="card">
          <div class="kicker">Personality</div>
          <div>${s.personality.traits||''}</div>
          <div class="muted">Ideal: ${s.personality.ideal||''}</div>
          <div class="muted">Bond/Rival/Friend: ${s.personality.bond||''}</div>
          <div class="muted">Goal: ${s.personality.goal||''}</div>
          <div class="muted" style="margin-top:6px">Prompt: ${s.personality.prompt||'—'}</div>
        </div>
      </div>
      <div class="controls">
        <div class="left"><button id="back_s">← Back</button></div>
        <div class="right">
          <button id="publish_roster">Add to Availability Roster</button>
          <button id="save_s">Save Draft</button>
          <button id="export_s" class="primary">Export JSON</button>
          <button id="pdf_s" class="success">Print / PDF</button>
        </div>
      </div>
    `;
    p.querySelector('#back_s').onclick=()=>{activateStep(STEPS.findIndex(s=>s.key==='personality'));};
    p.querySelector('#save_s').onclick=()=>State.save();
    p.querySelector('#export_s').onclick=()=>State.export();
    p.querySelector('#pdf_s').onclick=()=>window.print();
    const publishBtn = p.querySelector('#publish_roster');
    if(publishBtn){
      publishBtn.onclick = async ()=>{
        const name = sanitizeName(State.data?.core?.name);
        if(!name){ alert('Give your character a name in Core Setup first.'); return; }
        const key = rosterKey(name);
        const noteParts = [];
        if(State.data?.core?.class) noteParts.push(State.data.core.class);
        const uniName = uni ? uni.name : (DATA.universities.find(u=>u.key===State.data?.university?.key)?.name || '');
        if(uniName) noteParts.push(uniName);
        const notes = noteParts.join(' • ');
        const status = 'Interested';
        if(rosterHasKey(key)){
          const roster = getRosterList();
          const entry = roster.find(r=>r.key===key) || {name, custom:false};
          try{
            await updateRosterDetails(key, entry, status, notes);
            alert(`${name} is already on the roster. Updated their status and notes.`);
          }catch(err){
            alert(`Failed to update roster entry: ${err && err.message ? err.message : 'Request failed.'}`);
          }
        } else {
          const result = await addRosterExtra(name, status, notes);
          if(!result.ok){ alert(result.msg); return; }
          alert(`${name} added to the availability roster.`);
        }
      };
    }
    return p;
  }

  /* =======================
     BOOT
  ======================= */
  function renderAll(){
    try{
      renderNav();
      renderPanels();
      bindHeaderActions();
    } catch(err){
      showErrors([`Render failed: ${String(err && err.message || err)}`]);
      console.error(err);
    }
  }
  function bindHeaderActions(){
    const s = document.getElementById('btnSave'); if(s) s.onclick=()=>State.save();
    const l = document.getElementById('btnLoad'); if(l) l.onclick=()=>State.load();
    const e = document.getElementById('btnExport'); if(e) e.onclick=()=>State.export();
    const clr=document.getElementById('btnClear');
    if(clr){ clr.onclick=()=>{
      if(confirm('Clear all local data for this app?')){
        localStorage.removeItem('oracleTrialsSave');
        localStorage.removeItem('oracleOfflineState');
        alert('Local data cleared. Reloading…');
        location.reload();
      }
    }}
  }

  (async function(){
    const errs = validateConfig();
    if(errs.length){ showErrors(errs); bindHeaderActions(); return; }
    try{
      await SharedState.refresh();
    }catch(err){
      console.warn('Initial sync failed', err);
      NetworkStatus.setError('Unable to reach the shared datastore. Showing cached data if available.');
    }
    renderAll();
  })();
    
    
  </script>
</body>
</html>
